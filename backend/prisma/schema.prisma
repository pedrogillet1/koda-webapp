// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")        // Pooled connection (fast, for app queries)
  directUrl = env("DIRECT_DATABASE_URL") // Direct connection (slow, for migrations only)
}

// User model
model User {
  id               String   @id @default(uuid())
  email            String   @unique
  firstName        String?
  lastName         String?
  profileImage     String?
  passwordHash     String? // Null for OAuth users
  salt             String? // Null for OAuth users
  googleId         String?  @unique
  appleId          String?  @unique
  phoneNumber      String?  @unique
  isEmailVerified  Boolean  @default(false)
  isPhoneVerified  Boolean  @default(false)
  subscriptionTier String   @default("free") // free, personal, premium, business
  role             String   @default("user") // user, admin, lawyer, paralegal, accountant
  storageUsedBytes BigInt   @default(0)
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  // Zero-Knowledge Encryption Recovery
  recoveryKeyHash  String? // Hashed recovery key for account recovery (bcrypt)
  masterKeyEncrypted String? // Master encryption key encrypted with recovery key

  // Relations
  sessions          Session[]
  twoFactorAuth     TwoFactorAuth?
  documents         Document[]
  folders           Folder[]
  tags              Tag[]
  verificationCodes VerificationCode[]
  conversations     Conversation[]
  reminders         Reminder[]
  cloudIntegrations CloudIntegration[]
  auditLogs         AuditLog[]
  notifications     Notification[]
  userPreferences   UserPreferences?
  terminologyMaps   TerminologyMap[]
  sharedDocuments   DocumentShare[] @relation("SharedWith")
  ownedShares       DocumentShare[] @relation("Owner")
  actionHistory     ActionHistory[]

  // Memory system relations
  profile              UserProfile?
  preferencesMemory    UserPreference[]
  conversationTopics   ConversationTopic[]
  insights             UserInsight[]
  conversationSummaries ConversationSummary[]
  interactionMetadata  InteractionMetadata[]
  memories             Memory[]
  presentations        Presentation[]

  // Domain knowledge relations
  domainKnowledge      DomainKnowledge[]

  @@map("users")
}

// Session model for refresh tokens with advanced security tracking
model Session {
  id               String    @id @default(uuid())
  userId           String
  refreshTokenHash String
  expiresAt        DateTime
  createdAt        DateTime  @default(now())
  lastActivityAt   DateTime  @default(now())

  // IP Binding and Device Tracking
  ipAddress        String?   // IP address where session was created
  lastIpAddress    String?   // Last IP address used
  userAgent        String?   // Device and browser information
  deviceId         String?   // Unique device identifier
  deviceType       String?   // mobile, desktop, tablet
  deviceName       String?   // User-friendly device name (e.g., "Chrome on Windows")

  // Security Flags
  isActive         Boolean   @default(true)
  isSuspicious     Boolean   @default(false) // Flagged for suspicious activity
  suspicionReason  String?   // Why flagged as suspicious

  // Geolocation (optional)
  country          String?
  city             String?

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([deviceId])
  @@index([isActive])
  @@map("sessions")
}

// Two-Factor Authentication model
model TwoFactorAuth {
  id          String   @id @default(uuid())
  userId      String   @unique
  secret      String // Encrypted TOTP secret
  backupCodes String // Encrypted backup codes (JSON array)
  isEnabled   Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("two_factor_auth")
}

// Folder model for document organization
model Folder {
  id             String   @id @default(uuid())
  userId         String
  name           String
  description    String? // Optional description for the folder
  emoji          String? // Emoji icon for the folder
  color          String? // Color for UI representation
  parentFolderId String? // Null for root folders
  path           String? // Full path for display (e.g., "/Work/Projects/Q1")
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  // Encryption metadata (AES-256-GCM) - Zero-Knowledge Encryption for folder name
  nameEncrypted     String? // Encrypted folder name
  encryptionSalt    String? // PBKDF2 salt (base64)
  encryptionIV      String? // Initialization vector (base64)
  encryptionAuthTag String? // Authentication tag (base64)

  // Relations
  user         User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  parentFolder Folder?    @relation("FolderHierarchy", fields: [parentFolderId], references: [id], onDelete: Cascade)
  subfolders   Folder[]   @relation("FolderHierarchy")
  documents    Document[]

  @@index([userId])
  @@index([parentFolderId])
  @@index([path])
  @@index([userId, parentFolderId]) // ✅ Composite index for user's folder tree queries
  @@index([parentFolderId, name]) // ✅ Composite index for subfolder lookups with sorting
  @@map("folders")
}

// Category model for document classification (tags/labels)
model Category {
  id          String   @id @default(uuid())
  userId      String
  name        String // e.g., "Financial", "Legal", "Personal", "Work"
  description String? // Optional description
  color       String? // Hex color for UI
  icon        String? // Icon identifier or emoji
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  documents DocumentCategory[]

  @@unique([userId, name])
  @@index([userId])
  @@map("categories")
}

// Junction table for Document-Category many-to-many relationship
model DocumentCategory {
  id         String   @id @default(uuid())
  documentId String
  categoryId String
  createdAt  DateTime @default(now())

  // Relations
  document Document @relation(fields: [documentId], references: [id], onDelete: Cascade)
  category Category @relation(fields: [categoryId], references: [id], onDelete: Cascade)

  @@unique([documentId, categoryId])
  @@index([documentId])
  @@index([categoryId])
  @@map("document_categories")
}

// Document model
model Document {
  id                String   @id @default(uuid())
  userId            String
  folderId          String?
  filename          String
  encryptedFilename String // Actual filename in storage
  fileSize          Int
  mimeType          String
  fileHash          String // SHA-256 hash for integrity
  status            String   @default("processing") // processing, completed, failed
  parentVersionId   String? // For version control

  // Encryption metadata (AES-256-GCM) - Zero-Knowledge Encryption
  isEncrypted          Boolean  @default(false) // Flag for encrypted documents
  encryptionSalt       String? // PBKDF2 salt (base64)
  encryptionIV         String? // Initialization vector (base64)
  encryptionAuthTag    String? // Authentication tag (base64)
  filenameEncrypted    String? // Encrypted original filename
  extractedTextEncrypted String? // Encrypted extracted text (JSON with salt, iv, ciphertext, authTag)

  // Advanced Features: Interactive preview
  renderableContent String? // JSON structure for Manus-style preview (optional)

  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  // Relations
  user              User                  @relation(fields: [userId], references: [id], onDelete: Cascade)
  folder            Folder?               @relation(fields: [folderId], references: [id], onDelete: Cascade)
  parentVersion     Document?             @relation("DocumentVersions", fields: [parentVersionId], references: [id], onDelete: SetNull)
  versions          Document[]            @relation("DocumentVersions")
  metadata          DocumentMetadata?
  tags              DocumentTag[]
  categories        DocumentCategory[]
  summaries         DocumentSummary[]
  embeddings        DocumentEmbedding[]
  generatedDocument GeneratedDocument?

  @@index([userId])
  @@index([folderId])
  @@index([parentVersionId])
  @@index([userId, status])
  @@index([status])
  @@index([mimeType])
  @@index([userId, createdAt])
  @@index([userId, updatedAt])
  @@index([folderId, status]) // ✅ Composite index for folder contents filtering
  @@index([userId, folderId, status]) // ✅ Composite index for user's folder document queries
  @@index([filename]) // ✅ For filename search
  @@index([userId, filename]) // ✅ For user-specific filename search
  @@index([fileHash]) // ✅ For duplicate detection
  @@index([userId, fileHash, filename]) // ✅ For idempotency check (allows identical files with different names)
  @@map("documents")
}

// Document metadata (extracted text, OCR results, etc.)
model DocumentMetadata {
  id             String   @id @default(uuid())
  documentId     String   @unique
  extractedText  String? // Long text for extracted content
  ocrConfidence  Float?
  pageCount      Int? // Number of pages (for PDFs and multi-page documents)
  wordCount      Int? // Number of words in extracted text
  characterCount Int? // Number of characters in extracted text
  thumbnailUrl   String?
  entities       String? // JSON string of extracted entities
  classification String? // invoice, contract, receipt, etc.
  summary        String? // AI-generated 2-3 sentence summary for quick understanding

  // File properties (Phase 3 Enhancement)
  author            String? // Extracted from document properties
  creationDate      DateTime? // From file metadata
  modificationDate  DateTime? // From file metadata
  language          String? // Detected language (en, pt, es, etc.)

  // AI-generated metadata (Phase 3 Enhancement)
  topics            String? // JSON array of main topics
  keyEntities       String? // JSON array of people, companies, locations

  // Content flags (Phase 3 Enhancement)
  hasSignature      Boolean  @default(false)
  hasTables         Boolean  @default(false)
  hasImages         Boolean  @default(false)

  // Markdown conversion fields for deep linking
  markdownContent   String? // Full markdown text (for preview and editing)
  markdownUrl       String? // S3/GCS URL for large markdown files (alternative to storing in DB)
  markdownStructure String? // JSON: { headings: [...], sections: [...], toc: [...] }
  sheetCount        Int? // Number of sheets (for Excel documents)
  slideCount        Int? // Number of slides (for PowerPoint documents)

  // PowerPoint specific fields
  slidesData        String? // JSON: Array of slide objects with content
  pptxMetadata      String? // JSON: Presentation metadata (author, title, etc.)
  slideGenerationStatus String? @default("pending") // 'pending' | 'processing' | 'completed' | 'failed'
  slideGenerationError  String? // Error message if failed

  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  // Relations
  document Document @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@map("document_metadata")
}

// Tag model
model Tag {
  id        String   @id @default(uuid())
  userId    String
  name      String
  color     String? // Hex color for UI
  createdAt DateTime @default(now())

  // Relations
  user      User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  documents DocumentTag[]

  @@unique([userId, name])
  @@index([userId])
  @@map("tags")
}

// Junction table for Document-Tag many-to-many relationship
model DocumentTag {
  id         String   @id @default(uuid())
  documentId String
  tagId      String
  createdAt  DateTime @default(now())

  // Relations
  document Document @relation(fields: [documentId], references: [id], onDelete: Cascade)
  tag      Tag      @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@unique([documentId, tagId])
  @@index([documentId])
  @@index([tagId])
  @@map("document_tags")
}

// Verification codes for email and phone verification
model VerificationCode {
  id        String   @id @default(uuid())
  userId    String
  type      String // "email" or "phone"
  code      String // 6-digit verification code
  expiresAt DateTime
  isUsed    Boolean  @default(false)
  createdAt DateTime @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([code])
  @@map("verification_codes")
}

// Pending users waiting for email and phone verification
model PendingUser {
  id            String   @id @default(uuid())
  email         String   @unique
  passwordHash  String
  salt          String
  firstName     String?  // User's first name
  lastName      String?  // User's last name
  phoneNumber   String?
  emailCode     String?
  phoneCode     String?
  emailVerified Boolean  @default(false)
  phoneVerified Boolean  @default(false)
  expiresAt     DateTime // Expires after 24 hours if not verified
  createdAt     DateTime @default(now())

  // Zero-Knowledge Encryption Recovery
  recoveryKeyHash  String? // Hashed recovery key for account recovery (bcrypt)
  masterKeyEncrypted String? // Master encryption key encrypted with recovery key

  @@index([email])
  @@map("pending_users")
}

// Conversation model for chat history
model Conversation {
  id        String   @id @default(uuid())
  userId    String
  title     String   @default("New Chat")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Encryption metadata (AES-256-GCM) - Zero-Knowledge Encryption for title
  titleEncrypted    String? // Encrypted conversation title
  encryptionSalt    String? // PBKDF2 salt (base64)
  encryptionIV      String? // Initialization vector (base64)
  encryptionAuthTag String? // Authentication tag (base64)

  // Context tracking for folder/category-scoped conversations
  contextType   String?  // "folder" | "category" | "document" | null
  contextId     String?  // ID of the folder/category/document
  contextName   String?  // Display name for user reference
  contextMeta   Json?    // Additional metadata

  // ✅ NEW: P0 Features - Multi-turn conversation scope
  scopeDocumentIds String[] @default([])  // Current conversation scope (document IDs)
  scopeDescription String?                // Description of current scope

  // ✅ Chat History UX Features (Manus AI Guide #8)
  summary     String?  @db.Text // AI-generated summary of conversation
  isPinned    Boolean  @default(false) // Pin important conversations to the top
  isDeleted   Boolean  @default(false) // Soft delete flag
  deletedAt   DateTime? // Timestamp of deletion

  // Relations
  user        User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  messages    Message[]
  chatContexts ChatContext[]

  @@index([userId])
  @@index([contextType, contextId])
  @@index([userId, updatedAt])
  @@index([userId, isDeleted, isPinned, updatedAt]) // For efficient history queries
  @@map("conversations")
}

// Message model for chat messages
model Message {
  id             String   @id @default(uuid())
  conversationId String
  role           String // "user" or "assistant"
  content        String // The message text
  metadata       String? // JSON string for additional data (function calls, etc.)
  createdAt      DateTime @default(now())

  // Encryption metadata (AES-256-GCM) - Zero-Knowledge Encryption
  isEncrypted       Boolean  @default(false) // Flag for encrypted messages
  encryptionSalt    String? // PBKDF2 salt (base64)
  encryptionIV      String? // Initialization vector (base64)
  encryptionAuthTag String? // Authentication tag (base64)

  // Document generation fields
  isDocument      Boolean  @default(false) // Flag if this message contains a generated document
  documentTitle   String? // Title of the generated document
  documentFormat  String? // Format type: 'summary', 'analysis', 'deep_dive', 'report', 'general'
  markdownContent String? // Full markdown content of the document

  // ✅ NEW: P0 Features - Calculation and Context Tracking
  calculationResult Json?   // Stores calculation results (average, sum, growth, etc.)
  contextEntities   Json?   // Stores tracked entities (countries, years, metrics, topics)

  // Relations
  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  attachments  MessageAttachment[]
  chatDocuments ChatDocument[]

  @@index([conversationId])
  @@index([isDocument])
  @@index([conversationId, createdAt])
  @@map("messages")
}

// Chat Document model - Stores generated documents from chat with temporary expiry
model ChatDocument {
  id                String   @id @default(uuid())
  messageId         String
  conversationId    String
  userId            String

  // Document content
  title             String // Document title
  markdownContent   String // Full markdown content
  documentType      String? // 'summary', 'analysis', 'deep_dive', 'report', 'general'

  // Source information
  sourceDocumentId  String? // Optional reference to source document from library

  // Export URLs (generated on demand)
  pdfUrl            String? // S3/GCS URL for PDF export
  docxUrl           String? // S3/GCS URL for DOCX export

  // Metadata
  wordCount         Int?

  // Expiry for temporary documents
  createdAt         DateTime @default(now())
  expiresAt         DateTime? // Default: 30 days from creation

  // Relations
  message      Message @relation(fields: [messageId], references: [id], onDelete: Cascade)

  @@index([messageId])
  @@index([conversationId])
  @@index([userId])
  @@index([expiresAt])
  @@map("chat_documents")
}

// Message Attachment model - For documents generated/attached in chat
model MessageAttachment {
  id             String   @id @default(uuid())
  messageId      String
  conversationId String
  userId         String

  // Attachment type
  attachmentType String // 'analysis_document', 'comparison', 'summary', 'essay', 'generated_document'

  // Content
  title          String // Display name for the attachment
  content        String // JSON renderable content
  previewHtml    String? // Pre-generated HTML preview
  previewCss     String? // CSS for preview

  // Source documents (for analysis attachments)
  sourceDocumentIds String? // JSON array of source document IDs

  // Metadata
  analysisType   String? // 'comparison', 'summary', 'analysis', 'essay'
  metadata       String? // JSON: { options, prompts, etc. }

  // Edit tracking
  editHistory    String? // JSON array of edit records
  editCount      Int      @default(0)

  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  // Relations
  message      Message @relation(fields: [messageId], references: [id], onDelete: Cascade)

  @@index([messageId])
  @@index([conversationId])
  @@index([userId])
  @@index([attachmentType])
  @@map("message_attachments")
}

// Reminder/Notification model
model Reminder {
  id          String   @id @default(uuid())
  userId      String
  title       String
  description String?
  dueDate     DateTime
  isCompleted Boolean  @default(false)
  notified    Boolean  @default(false)
  documentId  String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  user          User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  notifications Notification[]

  @@index([userId])
  @@index([dueDate])
  @@map("reminders")
}

// Document Summary model
model DocumentSummary {
  id          String   @id @default(uuid())
  documentId  String
  summary     String // The generated summary text
  summaryType String   @default("standard") // brief, standard, or detailed
  createdAt   DateTime @default(now())

  // Relations
  document Document @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@index([documentId])
  @@map("document_summaries")
}

// Cloud Integration model for Google Drive, Dropbox, etc.
model CloudIntegration {
  id             String    @id @default(uuid())
  userId         String
  provider       String // "google_drive", "dropbox", etc.
  accessToken    String // Encrypted OAuth access token
  refreshToken   String? // Encrypted OAuth refresh token
  tokenExpiry    DateTime? // Token expiration time
  providerUserId String? // User ID from the cloud provider
  providerEmail  String? // Email from the cloud provider
  isActive       Boolean   @default(true)
  lastSyncedAt   DateTime?
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, provider])
  @@index([userId])
  @@map("cloud_integrations")
}

// Audit Log model for security tracking
model AuditLog {
  id        String   @id @default(uuid())
  userId    String? // Null for failed auth attempts
  action    String // login, logout, document_upload, document_download, etc.
  resource  String? // Resource ID (e.g., document ID)
  ipAddress String?
  userAgent String?
  status    String // success, failure
  details   String? // Additional JSON details
  createdAt DateTime @default(now())

  // Relations
  user User? @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([action])
  @@index([createdAt])
  @@map("audit_logs")
}

// Notification model
model Notification {
  id                String   @id @default(uuid())
  userId            String
  type              String // 'reminder', 'system', 'document_shared', 'storage_warning'
  title             String
  message           String
  relatedDocumentId String?
  relatedReminderId String?
  isRead            Boolean  @default(false)
  createdAt         DateTime @default(now())

  // Relations
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  relatedReminder Reminder? @relation(fields: [relatedReminderId], references: [id], onDelete: SetNull)

  @@index([userId, isRead])
  @@index([createdAt])
  @@map("notifications")
}

// User Preferences model
model UserPreferences {
  id                        String   @id @default(uuid())
  userId                    String   @unique
  emailNotificationsEnabled Boolean  @default(true)
  emailNotificationTypes    String? // JSON array of enabled types
  notificationFrequency     String   @default("immediate") // 'immediate', 'daily_digest', 'weekly_digest'
  createdAt                 DateTime @default(now())
  updatedAt                 DateTime @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_preferences")
}

// Document Entity model for pre-extracted structured data
model DocumentEntity {
  id              String   @id @default(uuid())
  documentId      String
  entityType      String // 'email', 'phone', 'address', 'date', 'amount', 'number', 'url', 'name', 'organization', 'location'
  value           String
  normalizedValue String // Normalized format for comparison
  pageNumber      Int
  textIndex       Int
  context         String // Surrounding text
  metadata        String? // JSON string for additional data
  createdAt       DateTime @default(now())

  @@index([documentId, entityType])
  @@index([documentId])
  @@index([entityType])
  @@index([value])
  @@index([normalizedValue])
  @@map("document_entities")
}

// Document Keyword model for fast keyword search
model DocumentKeyword {
  id         String   @id @default(uuid())
  documentId String
  word       String
  count      Int
  createdAt  DateTime @default(now())

  @@index([documentId])
  @@index([word])
  @@map("document_keywords")
}

// Document Embedding model for vector search (RAG)
model DocumentEmbedding {
  id          String   @id @default(uuid())
  documentId  String
  chunkIndex  Int // Which chunk (0, 1, 2, ...)
  content     String // The actual text chunk

  // Vector embedding stored as JSON array for SQLite compatibility
  // Format: [0.123, -0.456, 0.789, ...] (768 dimensions for Gemini)
  embedding   String // JSON array of floats

  // Metadata for source attribution and deep linking
  // JSON: {
  //   page, cell, sheet, slide, paragraph,
  //   startLine, endLine, sectionId, heading, headingLevel
  // }
  metadata    String

  createdAt   DateTime @default(now())

  // Relations
  document Document @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@index([documentId])
  @@index([documentId, chunkIndex])
  @@map("document_embeddings")
}

// Terminology Map for semantic query expansion
model TerminologyMap {
  id        String   @id @default(uuid())
  userId    String
  term      String // e.g., "revenue"
  synonyms  String // JSON array: ["income", "earnings", "sales"]
  domain    String // "banking", "legal", "general"
  createdAt DateTime @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, term, domain])
  @@index([userId])
  @@index([term])
  @@index([domain])
  @@map("terminology_maps")
}

// Chat Context for tracking RAG sources
model ChatContext {
  id             String   @id @default(uuid())
  conversationId String
  messageId      String? // Link to specific message

  // Source documents used in this context
  sourceDocuments String // JSON: [{ documentId, chunkIndexes, relevanceScore, citation }]

  // Research mode data (web sources)
  webSources     String? // JSON: [{ url, title, snippet, fetchedContent }]

  // Search metadata
  searchQuery    String? // Original query
  expandedTerms  String? // JSON: Terms after expansion

  createdAt      DateTime @default(now())

  // Relations
  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@index([conversationId])
  @@index([messageId])
  @@map("chat_contexts")
}

// Document Sharing model for RBAC
model DocumentShare {
  id             String   @id @default(uuid())
  documentId     String
  ownerId        String   // User who owns the document
  sharedWithId   String   // User the document is shared with
  permissionLevel String  @default("viewer") // viewer, editor, owner
  canDownload    Boolean  @default(true)
  canShare       Boolean  @default(false)
  canDelete      Boolean  @default(false)
  expiresAt      DateTime? // Optional expiration
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  // Relations
  owner        User @relation("Owner", fields: [ownerId], references: [id], onDelete: Cascade)
  sharedWith   User @relation("SharedWith", fields: [sharedWithId], references: [id], onDelete: Cascade)

  @@unique([documentId, sharedWithId])
  @@index([documentId])
  @@index([ownerId])
  @@index([sharedWithId])
  @@map("document_shares")
}

// API Usage Tracking for cost control
model APIUsage {
  id                String   @id @default(uuid())
  userId            String
  month             String   // Format: "2024-01" for January 2024
  geminiTokensUsed  Int      @default(0)
  embeddingRequests Int      @default(0)
  chatRequests      Int      @default(0)
  costUSD           Float    @default(0.0)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  @@unique([userId, month])
  @@index([userId])
  @@index([month])
  @@map("api_usage")
}

// RBAC: Role model
model Role {
  id          String   @id @default(uuid())
  name        String   @unique // admin, editor, viewer, custom
  description String?
  priority    Int      @default(0) // Higher priority = more permissions
  isSystem    Boolean  @default(false) // System roles cannot be deleted
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  permissions   RolePermission[]
  userRoles     UserRole[]
  childRoles    RoleHierarchy[] @relation("ParentRole")
  parentRoles   RoleHierarchy[] @relation("ChildRole")

  @@index([name])
  @@index([priority])
  @@map("roles")
}

// RBAC: Permission model
model Permission {
  id          String   @id @default(uuid())
  resource    String // documents, folders, users, settings, etc.
  action      String // create, read, update, delete, share, download
  description String?
  createdAt   DateTime @default(now())

  // Relations
  rolePermissions RolePermission[]

  @@unique([resource, action])
  @@index([resource])
  @@map("permissions")
}

// RBAC: Role-Permission junction table
model RolePermission {
  id           String   @id @default(uuid())
  roleId       String
  permissionId String
  createdAt    DateTime @default(now())

  // Relations
  role       Role       @relation(fields: [roleId], references: [id], onDelete: Cascade)
  permission Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)

  @@unique([roleId, permissionId])
  @@index([roleId])
  @@index([permissionId])
  @@map("role_permissions")
}

// RBAC: User-Role junction table (supports multiple roles per user)
model UserRole {
  id        String   @id @default(uuid())
  userId    String
  roleId    String
  grantedBy String? // User ID who granted this role
  expiresAt DateTime? // Optional role expiration
  createdAt DateTime @default(now())

  // Relations
  role Role @relation(fields: [roleId], references: [id], onDelete: Cascade)

  @@unique([userId, roleId])
  @@index([userId])
  @@index([roleId])
  @@map("user_roles")
}

// RBAC: Role hierarchy for role inheritance
model RoleHierarchy {
  id           String   @id @default(uuid())
  parentRoleId String
  childRoleId  String
  createdAt    DateTime @default(now())

  // Relations
  parentRole Role @relation("ParentRole", fields: [parentRoleId], references: [id], onDelete: Cascade)
  childRole  Role @relation("ChildRole", fields: [childRoleId], references: [id], onDelete: Cascade)

  @@unique([parentRoleId, childRoleId])
  @@index([parentRoleId])
  @@index([childRoleId])
  @@map("role_hierarchy")
}

// API Key model for programmatic access
model APIKey {
  id          String    @id @default(uuid())
  userId      String
  name        String // User-friendly name
  keyHash     String    @unique // Hashed API key
  keyPreview  String // Last 4 characters for display
  scopes      String // JSON array of scopes/permissions
  expiresAt   DateTime?
  lastUsedAt  DateTime?
  isActive    Boolean   @default(true)

  // Rate limiting
  rateLimit   Int       @default(1000) // Requests per hour
  usageCount  Int       @default(0) // Current usage in window
  windowStart DateTime  @default(now())

  // Metadata
  ipWhitelist String? // JSON array of allowed IPs
  userAgent   String? // User agent that created the key
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@index([userId])
  @@index([keyHash])
  @@index([isActive])
  @@map("api_keys")
}

// ==================== Advanced Features: Document Generation & Editing ====================

// Generated Document model - For AI-generated and comparison documents
model GeneratedDocument {
  id                String   @id @default(uuid())
  userId            String
  documentId        String   @unique // Link to the Document record
  generationType    String // 'comparison', 'summary', 'analysis', 'essay', 'from_prompt', 'template', 'ai_edit'

  // Chat integration
  conversationId    String? // Link to conversation for chat-based documents
  isTemporary       Boolean  @default(true) // Temporary until explicitly saved
  expiresAt         DateTime? // Expiration time for temporary documents (24 hours default)

  // Source information
  sourceDocumentIds String // JSON array of document IDs used as sources
  generationPrompt  String? // User's natural language prompt (if applicable)
  templateId        String? // Template used (if applicable)

  // Renderable content for preview (Manus-style)
  renderableContent String // JSON structure for real-time preview

  // Metadata
  metadata          String? // JSON: { comparisonType, templateData, editCommands, etc. }
  generatedAt       DateTime @default(now())
  savedAt           DateTime? // When user explicitly saved to Documents

  // Relations
  document          Document  @relation(fields: [documentId], references: [id], onDelete: Cascade)
  template          DocumentTemplate? @relation(fields: [templateId], references: [id], onDelete: SetNull)
  editHistory       DocumentEditHistory[]

  @@index([userId])
  @@index([documentId])
  @@index([generationType])
  @@index([templateId])
  @@index([conversationId])
  @@index([isTemporary])
  @@index([expiresAt])
  @@map("generated_documents")
}

// Document Template model - For structured document generation
model DocumentTemplate {
  id          String   @id @default(uuid())
  userId      String? // Null for system templates
  name        String
  description String?
  category    String // 'contract', 'report', 'invoice', 'letter', 'memo', etc.

  // Template structure
  structure   String // JSON: { sections: [...], fields: [...], formatting: {...} }

  // Metadata
  isSystem    Boolean  @default(false) // System templates cannot be deleted
  usageCount  Int      @default(0)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  generatedDocs GeneratedDocument[]

  @@index([userId])
  @@index([category])
  @@index([isSystem])
  @@map("document_templates")
}

// Document Edit History - Track AI edits and changes
model DocumentEditHistory {
  id                  String   @id @default(uuid())
  generatedDocumentId String
  editNumber          Int // Sequential edit counter (1, 2, 3, ...)

  // Edit details
  editType            String // 'ai_command', 'manual_edit', 'rollback'
  editCommand         String? // Natural language edit command (if AI)
  editDescription     String // Human-readable description of changes

  // Content snapshots
  contentBefore       String // JSON snapshot before edit
  contentAfter        String // JSON snapshot after edit

  // Metadata
  editedBy            String // User ID who made the edit
  editedAt            DateTime @default(now())

  // Relations
  generatedDocument GeneratedDocument @relation(fields: [generatedDocumentId], references: [id], onDelete: Cascade)

  @@index([generatedDocumentId])
  @@index([editNumber])
  @@index([editedBy])
  @@map("document_edit_history")
}

// ==================== Advanced Features: Excel Interactive Editing ====================

// Excel Sheet model - Cache sheet metadata for fast loading
model ExcelSheet {
  id          String   @id @default(uuid())
  documentId  String
  sheetIndex  Int // 0-based sheet index
  sheetName   String

  // Sheet metadata
  rowCount    Int
  columnCount Int
  metadata    String? // JSON: { frozenRows, frozenCols, filters, etc. }

  // Cache
  cachedAt    DateTime @default(now())
  expiresAt   DateTime // Cache expiration

  // Relations
  cells       ExcelCell[]

  @@unique([documentId, sheetIndex])
  @@index([documentId])
  @@index([expiresAt])
  @@map("excel_sheets")
}

// Excel Cell model - Cache individual cell data
model ExcelCell {
  id          String   @id @default(uuid())
  sheetId     String
  rowIndex    Int // 0-based row index
  colIndex    Int // 0-based column index

  // Cell data
  value       String? // Display value
  formula     String? // Formula if cell contains one
  dataType    String // 'string', 'number', 'boolean', 'date', 'formula', 'empty'

  // Formatting (basic)
  style       String? // JSON: { bold, italic, color, bgColor, alignment, etc. }

  // Cache
  cachedAt    DateTime @default(now())

  // Relations
  sheet ExcelSheet @relation(fields: [sheetId], references: [id], onDelete: Cascade)

  @@unique([sheetId, rowIndex, colIndex])
  @@index([sheetId])
  @@map("excel_cells")
}

// ==================== Advanced Features: Session-Based Document Analysis ====================

// AnalysisSession model - For temporary document analysis before saving
model AnalysisSession {
  id             String   @id @default(uuid())
  userId         String
  sessionType    String   @default("document_analysis") // document_analysis, comparison, research
  status         String   @default("active") // active, completed, expired

  // Session metadata
  documentCount  Int      @default(0)
  documentIds    String? // JSON array of document IDs in this session

  // Timestamps
  createdAt      DateTime @default(now())
  expiresAt      DateTime // Auto-expire after 24 hours
  completedAt    DateTime?

  // Relations
  documents      SessionDocument[]

  @@index([userId])
  @@index([status])
  @@index([expiresAt])
  @@map("analysis_sessions")
}

// Session Document model - Temporary documents in a session
model SessionDocument {
  id             String   @id @default(uuid())
  sessionId      String
  userId         String

  // Document info
  filename       String
  fileSize       Int
  mimeType       String
  fileType       String // pdf, docx, xlsx, etc.

  // Processing status
  status         String   @default("processing") // processing, completed, failed

  // Extracted content (stored temporarily in Redis, metadata here for reference)
  extractedText  String? // Could be stored in Redis instead
  wordCount      Int?
  pageCount      Int?

  // Timestamps
  uploadedAt     DateTime @default(now())
  processedAt    DateTime?

  // Relations
  session        AnalysisSession  @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@index([sessionId])
  @@index([userId])
  @@index([status])
  @@map("session_documents")
}

// ==================== KODA FIX: Undo/Redo Action History ====================

// Action History model for tracking file operations (undo/redo)
model ActionHistory {
  id           String   @id @default(uuid())
  userId       String
  actionType   String // create, delete, rename, move
  targetPath   String // The file path affected
  previousPath String? // For rename/move operations
  fileContent  String? // For create/delete operations (to restore)
  fileType     String? // File type/extension
  canUndo      Boolean  @default(true)
  canRedo      Boolean  @default(false)
  timestamp    DateTime @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([canUndo])
  @@index([canRedo])
  @@index([timestamp])
  @@map("action_history")
}

// ════════════════════════════════════════════════════════════════════════════════
// CONVERSATIONAL MEMORY SYSTEM - ChatGPT-style Memory
// ════════════════════════════════════════════════════════════════════════════════

// User Profile - Basic user information
model UserProfile {
  id        String   @id @default(uuid())
  userId    String   @unique
  name      String?
  role      String?  // e.g., "lawyer", "accountant", "student"
  organization String?
  expertiseLevel String? // "beginner", "intermediate", "expert"
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("user_profiles")
}

// User Preferences - How user prefers responses
model UserPreference {
  id              String   @id @default(uuid())
  userId          String
  preferenceType  String   // 'response_format', 'detail_level', 'citation_style', 'language'
  preferenceValue String   // e.g., "bullet_points", "detailed", "apa", "en"
  confidence      Float    @default(0.5) // 0.0 to 1.0
  evidence        String?  // JSON: examples that support this preference
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([userId, preferenceType])
  @@map("user_preferences_memory")
}

// Conversation Topics - High-level topics from past conversations
model ConversationTopic {
  id           String   @id @default(uuid())
  userId       String
  topicSummary String   // e.g., "User frequently analyzes financial documents"
  firstSeen    DateTime
  lastSeen     DateTime
  frequency    Int      @default(1)
  confidence   Float    @default(0.5) // 0.0 to 1.0

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([userId, lastSeen])
  @@map("conversation_topics")
}

// User Insights - Learned patterns about user
model UserInsight {
  id          String   @id @default(uuid())
  userId      String
  insightType String   // 'expertise', 'interest', 'pattern', 'goal'
  insightText String   // e.g., "User is interested in tax optimization"
  confidence  Float    @default(0.5) // 0.0 to 1.0
  evidence    String?  // JSON: examples that support this insight
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([userId, insightType])
  @@map("user_insights")
}

// Recent Conversation Summaries - Last ~40 conversations
model ConversationSummary {
  id             String   @id @default(uuid())
  userId         String
  conversationId String
  summary        String   // Brief summary of conversation
  userMessages   String[] // Array of user messages
  timestamp      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([userId, timestamp])
  @@map("conversation_summaries")
}

// Interaction Metadata - Usage patterns
model InteractionMetadata {
  id            String   @id @default(uuid())
  userId        String
  metadataType  String   // 'activity_pattern', 'query_length', 'intent_tag', 'complexity'
  metadataValue String   // JSON or simple value
  updatedAt     DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, metadataType])
  @@index([userId])
  @@map("interaction_metadata")
}

// ════════════════════════════════════════════════════════════════════════════════
// CROSS-SESSION MEMORY SYSTEM - ChatGPT-style Memory (Phase 3 Feature 3.1)
// ════════════════════════════════════════════════════════════════════════════════

enum MemorySection {
  USER_PREFERENCES
  WORK_CONTEXT
  PERSONAL_FACTS
  GOALS
  COMMUNICATION_STYLE
  RELATIONSHIPS
}

model Memory {
  id            String        @id @default(cuid())
  userId        String
  user          User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  section       MemorySection
  content       String        @db.Text
  importance    Int           @default(5)

  createdAt     DateTime      @default(now())
  lastAccessed  DateTime      @default(now())
  accessCount   Int           @default(0)

  source        String?
  metadata      Json?

  @@index([userId, section])
  @@index([userId, importance])
  @@index([lastAccessed])
  @@map("memories")
}

// ════════════════════════════════════════════════════════════════════════════════
// METHODOLOGY KNOWLEDGE BASE - Conceptual Understanding of Methods/Techniques
// ════════════════════════════════════════════════════════════════════════════════
// PURPOSE: Store extracted knowledge about methodologies, techniques, and concepts
// WHY: Enable Koda to explain "what is X" with actual understanding, not just citations
// EXAMPLE: "What is ensemble learning?" → Full explanation + how user's papers use it

model MethodologyKnowledge {
  id              String   @id @default(uuid())
  userId          String

  // Core identification
  name            String        // Normalized methodology name (e.g., "ensemble learning")
  aliases         String?       // JSON array of alternative names (e.g., ["ensemble methods", "model ensemble"])

  // Knowledge content
  definition      String?  @db.Text  // What it is (1-2 sentences)
  howItWorks      String?  @db.Text  // How the method works (step-by-step or explanation)
  whyUsed         String?  @db.Text  // Why this method is used / advantages
  limitations     String?  @db.Text  // Known limitations or disadvantages
  useCases        String?  @db.Text  // Common applications / when to use it
  examples        String?  @db.Text  // Concrete examples from user's documents

  // Relationships to other methodologies
  relatedMethods  String?       // JSON array of related methodology names
  parentMethod    String?       // "is a type of" relationship (e.g., "machine learning")
  childMethods    String?       // JSON array of sub-methods (e.g., ["bagging", "boosting", "stacking"])

  // Source tracking
  sourceDocumentIds String?     // JSON array of document IDs where this was found
  documentCount     Int      @default(1)  // Number of documents mentioning this methodology
  extractedFrom     String?  @db.Text  // Original text snippets used for extraction

  // Quality metrics
  confidence      Float    @default(0.5)  // 0-1 confidence score for extracted knowledge
  isVerified      Boolean  @default(false)  // Manually verified by user

  // Timestamps
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  lastAccessedAt  DateTime @default(now())
  accessCount     Int      @default(0)

  @@unique([userId, name])
  @@index([userId])
  @@index([name])
  @@index([userId, name])
  @@index([confidence])
  @@index([documentCount])
  @@map("methodology_knowledge")
}

// ==================== Domain Knowledge: Build Expertise from Documents ====================

// Domain Knowledge model - Store domain-specific terms, definitions, formulas
model DomainKnowledge {
  id              String   @id @default(uuid())
  userId          String

  // Core identification
  term            String        // The term/concept (e.g., "Sharpe ratio", "overfitting")
  normalizedTerm  String        // Lowercase, normalized version for matching
  domain          String        // Domain category: finance, ml, statistics, economics, etc.

  // Knowledge content
  definition      String?  @db.Text  // What it is (concise definition)
  formula         String?  @db.Text  // Mathematical formula if applicable (LaTeX or text)
  interpretation  String?  @db.Text  // How to interpret/use this (e.g., "higher is better, >1 is good")
  usageContext    String?  @db.Text  // When/where this is used
  examples        String?  @db.Text  // Examples from user's documents

  // Relationships
  relatedTerms    String?       // JSON array of related term names
  parentTerm      String?       // Broader concept (e.g., "risk-adjusted return" for "Sharpe ratio")
  childTerms      String?       // JSON array of more specific terms
  synonyms        String?       // JSON array of synonyms/alternative names

  // Source tracking
  sourceDocumentIds String?     // JSON array of document IDs where this was found
  documentCount     Int      @default(1)  // Number of documents mentioning this term
  extractedContext  String?  @db.Text  // Original context snippets

  // Quality metrics
  confidence      Float    @default(0.5)  // 0-1 confidence score
  isVerified      Boolean  @default(false)  // Manually verified by user

  // Timestamps
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  lastAccessedAt  DateTime @default(now())
  accessCount     Int      @default(0)

  // Relations
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  outgoingRelations ConceptRelationship[] @relation("FromConcept")
  incomingRelations ConceptRelationship[] @relation("ToConcept")

  @@unique([userId, normalizedTerm, domain])
  @@index([userId])
  @@index([term])
  @@index([normalizedTerm])
  @@index([domain])
  @@index([userId, domain])
  @@map("domain_knowledge")
}

// Concept Relationship model - Track relationships between concepts
model ConceptRelationship {
  id              String   @id @default(uuid())
  userId          String

  // Relationship endpoints
  fromConceptId   String
  toConceptId     String

  // Relationship type
  relationshipType String  // uses, measures, reduces, causes, requires, etc.
  strength         Float   @default(0.5)  // 0-1 relationship strength
  description      String? // Optional description of the relationship

  // Source tracking
  sourceDocumentIds String?  // JSON array of document IDs where this relationship was found
  documentCount     Int      @default(1)

  // Timestamps
  createdAt       DateTime @default(now())

  // Relations
  fromConcept     DomainKnowledge @relation("FromConcept", fields: [fromConceptId], references: [id], onDelete: Cascade)
  toConcept       DomainKnowledge @relation("ToConcept", fields: [toConceptId], references: [id], onDelete: Cascade)

  @@unique([fromConceptId, toConceptId, relationshipType])
  @@index([userId])
  @@index([fromConceptId])
  @@index([toConceptId])
  @@index([relationshipType])
  @@map("concept_relationships")
}

// ════════════════════════════════════════════════════════════════════════════════
// CAUSAL RELATIONSHIPS - Store extracted cause-effect relationships
// ════════════════════════════════════════════════════════════════════════════════
// PURPOSE: Store causal relationships for answering "why" questions
// WHY: "Why did GDP drop?" needs explanation like "due to pandemic lockdowns"
// EXAMPLE: "GDP decline" was "caused by" "COVID-19 pandemic lockdowns"

model CausalRelationship {
  id              String   @id @default(uuid())
  userId          String

  // Core causal relationship
  effect          String   @db.Text  // The effect/outcome (e.g., "GDP dropped 15%")
  causes          String   @db.Text  // JSON array of causes with confidence scores
                                     // [{ cause: "pandemic", confidence: 0.9, pattern: "due to" }]

  // Evidence and context
  evidence        String?  @db.Text  // Supporting evidence (quantitative data, quotes)
  context         String?  @db.Text  // Contextual information (time period, conditions)
  mechanism       String?  @db.Text  // How the cause leads to effect (the "how")

  // Classification
  domain          String?       // Domain: economics, finance, technology, etc.
  causalType      String?       // Type: direct, indirect, contributing, necessary, sufficient

  // Source tracking
  sourceDocumentIds String?     // JSON array of document IDs
  documentCount     Int      @default(1)
  extractedPatterns String?     // JSON: patterns used to extract (e.g., ["due to", "caused by"])

  // Quality metrics
  confidence      Float    @default(0.5)  // 0-1 overall confidence
  isVerified      Boolean  @default(false)  // User verified

  // Timestamps
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([userId])
  @@index([userId, domain])
  @@index([confidence])
  @@map("causal_relationships")
}

// ════════════════════════════════════════════════════════════════════════════════
// COMPARATIVE DATA - Store comparison information between concepts
// ════════════════════════════════════════════════════════════════════════════════
// PURPOSE: Store structured comparisons for answering "compare X vs Y" questions
// WHY: "Compare RL and portfolio optimization" needs actual attribute comparison
// EXAMPLE: Approach: RL uses "trial-and-error", PO uses "mathematical optimization"

model ComparativeData {
  id              String   @id @default(uuid())
  userId          String

  // Concepts being compared
  conceptA        String        // First concept (e.g., "reinforcement learning")
  conceptB        String        // Second concept (e.g., "portfolio optimization")

  // Structured comparison attributes
  attributes      String   @db.Text  // JSON object: { aspect: { conceptA: value, conceptB: value } }
                                     // e.g., { "approach": { "rl": "trial-and-error", "po": "optimization" } }

  // Comparative statements found in documents
  comparativeStatements String? @db.Text  // JSON array of comparative statements
                                          // [{ pattern: "unlike", text: "Unlike RL, PO uses...", source: "doc123" }]

  // Synthesized insights
  keyInsight      String?  @db.Text  // Synthesized key insight about the comparison
  similarities    String?  @db.Text  // JSON array of similarities
  differences     String?  @db.Text  // JSON array of differences

  // Source tracking
  sourceDocumentIds String?     // JSON array of document IDs
  documentCount     Int      @default(1)

  // Quality metrics
  confidence      Float    @default(0.5)
  isVerified      Boolean  @default(false)

  // Timestamps
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@unique([userId, conceptA, conceptB])
  @@index([userId])
  @@index([conceptA])
  @@index([conceptB])
  @@map("comparative_data")
}

// ════════════════════════════════════════════════════════════════════════════════
// PRACTICAL RECOMMENDATIONS - Store extracted actionable recommendations
// ════════════════════════════════════════════════════════════════════════════════
// PURPOSE: Store recommendations for answering "what should I do" questions
// WHY: "What does this mean for my strategy?" needs actionable guidance
// EXAMPLE: "Use ensemble methods" with evidence "15-20% better Sharpe ratio"

model PracticalRecommendation {
  id              String   @id @default(uuid())
  userId          String

  // Core recommendation
  recommendation  String   @db.Text  // The recommendation text
  category        String        // Category: Strategy Design, Risk Management, Implementation, etc.
  strength        String        // strong, moderate, weak

  // Supporting data
  evidence        String?  @db.Text  // Quantitative evidence supporting this
  rationale       String?  @db.Text  // Why this is recommended
  thresholds      String?  @db.Text  // JSON: quantitative thresholds { metric, value, direction }

  // Context
  domain          String?       // Domain this applies to
  applicability   String?  @db.Text  // When/where this applies

  // Source tracking
  sourceDocumentIds String?     // JSON array of document IDs
  documentCount     Int      @default(1)  // Number of documents supporting this
  consensusLevel    String?      // single, multiple, consensus (if found in many docs)

  // Quality metrics
  confidence      Float    @default(0.5)
  isVerified      Boolean  @default(false)

  // Timestamps
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([userId])
  @@index([category])
  @@index([userId, category])
  @@index([strength])
  @@index([consensusLevel])
  @@map("practical_recommendations")
}

// ════════════════════════════════════════════════════════════════════════════════
// TREND PATTERN - Store extracted trends and patterns from documents
// ════════════════════════════════════════════════════════════════════════════════
// PURPOSE: Store temporal trends for answering "what's the trend" questions
// WHY: "What's the trend in AI adoption?" needs actual trend data, not counts

model TrendPattern {
  id              String   @id @default(uuid())
  userId          String

  // Core trend identification
  subject         String        // What is trending (e.g., "AI adoption", "ESG investing")
  trendType       String        // increasing, decreasing, stable, cyclical, emerging
  timeframe       String?       // Time period (e.g., "2020-2024", "last 5 years")

  // Trend details
  description     String   @db.Text  // Description of the trend
  dataPoints      String?  @db.Text  // JSON: [{ period, value, source }]
  magnitude       String?       // Description of magnitude (e.g., "30% growth", "2x increase")

  // Drivers and implications
  drivers         String?  @db.Text  // What's driving the trend
  implications    String?  @db.Text  // What this trend means / implications

  // Source tracking
  sourceDocumentIds String?     // JSON array of document IDs
  documentCount     Int      @default(1)

  // Quality metrics
  confidence      Float    @default(0.5)
  isVerified      Boolean  @default(false)

  // Timestamps
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([userId])
  @@index([subject])
  @@index([trendType])
  @@index([userId, trendType])
  @@map("trend_patterns")
}

// ════════════════════════════════════════════════════════════════════════════════
// P0 FEATURES: Knowledge Base for Academic Intelligence
// ════════════════════════════════════════════════════════════════════════════════

// Knowledge Entry model - General knowledge extraction storage
model KnowledgeEntry {
  id           String   @id @default(uuid())
  documentId   String
  type         String   // "definition", "methodology", "trend", "causal", "comparison", "implication"
  content      String   @db.Text
  metadata     Json?    // Additional structured data

  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@index([documentId])
  @@index([type])
  @@index([documentId, type])
  @@map("knowledge_entries")
}

// Folder Summary model - Cached folder analysis
model FolderSummary {
  id           String   @id @default(uuid())
  folderId     String   @unique
  userId       String
  summary      String   @db.Text       // Generated summary of folder contents
  documentCount Int                    // Number of documents in folder
  themes       String[] @default([])   // Key themes extracted from folder
  lastDocumentAddedAt DateTime?        // When last document was added

  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@index([userId])
  @@index([folderId])
  @@map("folder_summaries")
}


// ════════════════════════════════════════════════════════════════════════════════
// PRESENTATION GENERATION SYSTEM (Manus-Style Slides)
// ════════════════════════════════════════════════════════════════════════════════

// Presentation model - Stores presentation metadata and configuration
model Presentation {
  id          String   @id @default(uuid())
  userId      String
  title       String
  description String?  @db.Text
  status      String   @default("draft") // draft, generating, completed, failed
  
  // Style configuration (Koda design system)
  colorPalette        String?  @db.Text // JSON: primary, secondary, accent colors
  typography          String?  @db.Text // JSON: font families and sizes
  aestheticDirection  String?  @db.Text // Design direction description
  
  // Metadata
  totalSlides  Int      @default(0)
  viewCount    Int      @default(0)
  lastViewedAt DateTime?
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relations
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  slides      Slide[]
  
  @@index([userId])
  @@index([status])
  @@index([createdAt])
  @@map("presentations")
}

// Slide model - Individual slides within a presentation
model Slide {
  id              String   @id @default(uuid())
  presentationId  String
  slideNumber     Int      // Order of slide in presentation (1-indexed)
  
  // Content
  title           String
  summary         String?  @db.Text // Brief description of slide content
  htmlContent     String   @db.Text // Full HTML content with styling
  
  // Layout and design
  layout          String   // title, content, two-column, chart, image, custom
  template        String?  // Template variant used
  
  // Status
  status          String   @default("pending") // pending, generating, completed, failed
  errorMessage    String?  @db.Text
  
  // Metadata
  generatedAt     DateTime?
  renderTime      Int?     // Time taken to generate (ms)
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  // Relations
  presentation    Presentation @relation(fields: [presentationId], references: [id], onDelete: Cascade)
  
  @@unique([presentationId, slideNumber])
  @@index([presentationId])
  @@index([status])
  @@map("slides")
}

// ════════════════════════════════════════════════════════════════════════════════
// INFINITE CONVERSATION MEMORY SYSTEM - Manus-style Architecture
// ════════════════════════════════════════════════════════════════════════════════
// PURPOSE: Enable infinite conversation memory through semantic chunking and retrieval
// WHY: Prevent context overflow, enable "which chat was this in?", never forget
// HOW: Chunk conversations → Embed chunks → Retrieve semantically when needed

// Conversation Chunk - Semantic segments of conversations with embeddings
model ConversationChunk {
  id              String   @id @default(uuid())
  conversationId  String
  userId          String
  
  // Message range this chunk covers
  startMessageId  String
  endMessageId    String
  messageCount    Int      @default(0)
  
  // Content
  content         String   @db.Text  // Full text of messages in this chunk
  summary         String   @db.Text  // AI-generated summary of chunk
  
  // Semantic metadata
  topics          String[]           // Extracted topics (e.g., ["budget", "Q4 revenue"])
  entities        String[]           // Named entities (e.g., ["Budget 2024.xlsx", "John"])
  keywords        String[]           // Key terms for search
  
  // Vector embedding metadata
  vectorId        String?  @unique   // Pinecone vector ID
  embeddingModel  String   @default("text-embedding-004")
  
  // Quality metrics
  importance      Float    @default(0.5)  // 0-1 score for chunk importance
  coherence       Float    @default(0.5)  // 0-1 score for topic coherence
  
  // Timestamps
  firstMessageAt  DateTime           // Timestamp of first message in chunk
  lastMessageAt   DateTime           // Timestamp of last message in chunk
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  @@index([conversationId])
  @@index([userId])
  @@index([vectorId])
  @@index([conversationId, lastMessageAt])
  @@index([userId, lastMessageAt])
  @@map("conversation_chunks")
}

// Conversation Index - High-level conversation summaries for cross-chat search
model ConversationIndex {
  id              String   @id @default(uuid())
  conversationId  String   @unique
  userId          String
  
  // Conversation metadata
  title           String
  summary         String   @db.Text  // Overall conversation summary
  
  // Semantic metadata
  mainTopics      String[]           // Primary topics discussed
  keyEntities     String[]           // Important entities mentioned
  keywords        String[]           // Searchable keywords
  
  // Statistics
  messageCount    Int      @default(0)
  chunkCount      Int      @default(0)
  userMessageCount Int     @default(0)
  assistantMessageCount Int @default(0)
  
  // Vector embedding metadata
  vectorId        String?  @unique   // Pinecone vector ID for conversation-level search
  embeddingModel  String   @default("text-embedding-004")
  
  // Timestamps
  firstMessageAt  DateTime
  lastMessageAt   DateTime
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  @@index([userId])
  @@index([vectorId])
  @@index([userId, lastMessageAt])
  @@map("conversation_indexes")
}

// Conversation Context State - Tracks what's currently in context window
model ConversationContextState {
  id              String   @id @default(uuid())
  conversationId  String   @unique
  userId          String
  
  // Current context composition
  recentMessageIds     String[]      // IDs of recent messages in context
  retrievedChunkIds    String[]      // IDs of chunks retrieved for context
  memoryIds            String[]      // IDs of memories included in context
  
  // Token usage tracking
  totalTokens          Int    @default(0)
  recentMessagesTokens Int    @default(0)
  chunksTokens         Int    @default(0)
  memoriesTokens       Int    @default(0)
  documentsTokens      Int    @default(0)
  
  // Compression state
  isCompressed         Boolean @default(false)
  compressionLevel     Int     @default(0)  // 0=none, 1=light, 2=medium, 3=heavy
  lastCompressedAt     DateTime?
  
  // Last query context
  lastQuery            String?  @db.Text
  lastQueryEmbedding   Json?    // Store for similarity comparison
  
  updatedAt            DateTime @updatedAt
  
  @@index([conversationId])
  @@index([userId])
  @@map("conversation_context_states")
}

// ════════════════════════════════════════════════════════════════════════════════
// ANALYTICS SYSTEM - Admin Dashboard Data
// ════════════════════════════════════════════════════════════════════════════════

// Daily aggregated statistics for historical tracking
model AnalyticsDailyStat {
  id                    String   @id @default(uuid())
  date                  DateTime @unique // The date for these stats (stored as midnight UTC)

  // User metrics
  totalUsers            Int      @default(0)
  newUsers              Int      @default(0)
  activeUsers           Int      @default(0)

  // Conversation metrics
  totalConversations    Int      @default(0)
  newConversations      Int      @default(0)

  // Message metrics
  totalMessages         Int      @default(0)
  userMessages          Int      @default(0)
  assistantMessages     Int      @default(0)

  // Document metrics
  totalDocuments        Int      @default(0)
  newDocuments          Int      @default(0)
  storageUsedBytes      BigInt   @default(0)

  // System metrics
  errorCount            Int      @default(0)
  avgResponseTimeMs     Int      @default(0)

  // Cost metrics
  estimatedCostUSD      Float    @default(0)
  geminiApiCalls        Int      @default(0)
  embeddingCalls        Int      @default(0)

  // Timestamps
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  @@index([date])
  @@map("analytics_daily_stats")
}

// User activity tracking for detailed analytics
model AnalyticsUserActivity {
  id                    String   @id @default(uuid())
  userId                String
  date                  DateTime // The date of activity

  // Activity counts
  sessionsCount         Int      @default(0)
  messagesSent          Int      @default(0)
  documentsUploaded     Int      @default(0)
  conversationsCreated  Int      @default(0)
  ragQueriesCount       Int      @default(0)

  // Engagement metrics
  totalActiveMinutes    Int      @default(0)
  lastActiveAt          DateTime?

  // Feature usage
  featuresUsed          String[] @default([]) // Array of feature names used

  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  @@unique([userId, date])
  @@index([userId])
  @@index([date])
  @@index([userId, date])
  @@map("analytics_user_activity")
}

// System health snapshots for monitoring
model AnalyticsSystemHealth {
  id                    String   @id @default(uuid())
  timestamp             DateTime @default(now())

  // Database metrics
  databaseConnections   Int      @default(0)
  databaseSizeBytes     BigInt   @default(0)
  slowQueryCount        Int      @default(0)

  // API metrics
  requestsPerMinute     Int      @default(0)
  avgResponseTimeMs     Int      @default(0)
  errorRate             Float    @default(0)

  // Server metrics
  cpuUsagePercent       Float    @default(0)
  memoryUsagePercent    Float    @default(0)
  diskUsagePercent      Float    @default(0)

  // External services
  pineconeLatencyMs     Int      @default(0)
  geminiLatencyMs       Int      @default(0)
  s3LatencyMs           Int      @default(0)

  @@index([timestamp])
  @@map("analytics_system_health")
}

// Error tracking for debugging and monitoring
model AnalyticsError {
  id                    String   @id @default(uuid())
  timestamp             DateTime @default(now())

  // Error details
  errorType             String   // 'api_error', 'database_error', 'external_service', 'validation', etc.
  errorCode             String?  // HTTP status code or custom error code
  errorMessage          String   @db.Text
  stackTrace            String?  @db.Text

  // Context
  endpoint              String?  // API endpoint that caused the error
  method                String?  // HTTP method
  userId                String?  // User who triggered the error (if known)
  requestBody           String?  @db.Text // Sanitized request body

  // Resolution
  isResolved            Boolean  @default(false)
  resolvedAt            DateTime?
  resolvedBy            String?  // Admin who resolved it
  resolution            String?  @db.Text // How it was resolved

  // Grouping
  fingerprint           String?  // Hash for grouping similar errors
  occurrenceCount       Int      @default(1)
  firstOccurrence       DateTime @default(now())
  lastOccurrence        DateTime @default(now())

  @@index([timestamp])
  @@index([errorType])
  @@index([fingerprint])
  @@index([isResolved])
  @@index([userId])
  @@map("analytics_errors")
}

// Admin action audit log
model AdminAuditLog {
  id                    String   @id @default(uuid())
  adminUserId           String
  timestamp             DateTime @default(now())

  // Action details
  action                String   // 'view_analytics', 'export_data', 'clear_cache', etc.
  resource              String?  // What was accessed/modified
  resourceId            String?  // ID of the resource

  // Request details
  ipAddress             String?
  userAgent             String?

  // Additional data
  details               Json?    // Additional context

  @@index([adminUserId])
  @@index([timestamp])
  @@index([action])
  @@map("admin_audit_logs")
}
