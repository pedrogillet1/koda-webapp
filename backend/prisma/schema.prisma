generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_DATABASE_URL")
}

model User {
  id                    String                @id @default(uuid())
  email                 String                @unique
  firstName             String?
  lastName              String?
  profileImage          String?
  passwordHash          String?
  salt                  String?
  googleId              String?               @unique
  appleId               String?               @unique
  phoneNumber           String?               @unique
  isEmailVerified       Boolean               @default(false)
  isPhoneVerified       Boolean               @default(false)
  subscriptionTier      String                @default("free")
  role                  String                @default("user")
  storageUsedBytes      BigInt                @default(0)
  createdAt             DateTime              @default(now())
  updatedAt             DateTime              @updatedAt
  recoveryKeyHash       String?
  masterKeyEncrypted    String?
  actionHistory         ActionHistory[]
  auditLogs             AuditLog[]

  conversationTopics    ConversationTopic[]
  conversations         Conversation[]
  ownedShares           DocumentShare[]       @relation("Owner")
  sharedDocuments       DocumentShare[]       @relation("SharedWith")
  documents             Document[]
  domainKnowledge       DomainKnowledge[]
  folders               Folder[]

  memories              Memory[]

  presentations         Presentation[]
  reminders             Reminder[]
  sessions              Session[]
  tags                  Tag[]
  terminologyMaps       TerminologyMap[]
  twoFactorAuth         TwoFactorAuth?

  userPreferences       UserPreferences?
  preferencesMemory     UserPreference[]
  profile               UserProfile?
  verificationCodes     VerificationCode[]

  // Analytics relations
  userSessions          UserSession[]
  analyticsEvents       AnalyticsEvent[]
  conversationFeedback  ConversationFeedback[]
  ragQueryMetrics       RAGQueryMetrics[]
  userLifetimeValue     UserLifetimeValue?
  featureUsageLogs      FeatureUsageLog[]

  @@map("users")
}

model Session {
  id               String   @id @default(uuid())
  userId           String
  refreshTokenHash String
  expiresAt        DateTime
  createdAt        DateTime @default(now())
  lastActivityAt   DateTime @default(now())
  ipAddress        String?
  lastIpAddress    String?
  userAgent        String?
  deviceId         String?
  deviceType       String?
  deviceName       String?
  isActive         Boolean  @default(true)
  isSuspicious     Boolean  @default(false)
  suspicionReason  String?
  country          String?
  city             String?
  user             User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([deviceId])
  @@index([isActive])
  @@map("sessions")
}

model TwoFactorAuth {
  id          String   @id @default(uuid())
  userId      String   @unique
  secret      String
  backupCodes String
  isEnabled   Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("two_factor_auth")
}

model Folder {
  id                String     @id @default(uuid())
  userId            String
  name              String
  description       String?
  emoji             String?
  color             String?
  parentFolderId    String?
  path              String?
  createdAt         DateTime   @default(now())
  updatedAt         DateTime   @updatedAt
  nameEncrypted     String?
  encryptionSalt    String?
  encryptionIV      String?
  encryptionAuthTag String?
  documents         Document[]
  parentFolder      Folder?    @relation("FolderHierarchy", fields: [parentFolderId], references: [id], onDelete: Cascade)
  subfolders        Folder[]   @relation("FolderHierarchy")
  user              User       @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([parentFolderId])
  @@index([path])
  @@index([userId, parentFolderId])
  @@index([parentFolderId, name])
  @@map("folders")
}

model Category {
  id          String             @id @default(uuid())
  userId      String
  name        String
  description String?
  color       String?
  icon        String?
  createdAt   DateTime           @default(now())
  updatedAt   DateTime           @updatedAt
  documents   DocumentCategory[]

  @@unique([userId, name])
  @@index([userId])
  @@map("categories")
}

model DocumentCategory {
  id         String   @id @default(uuid())
  documentId String
  categoryId String
  createdAt  DateTime @default(now())
  category   Category @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  document   Document @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@unique([documentId, categoryId])
  @@index([documentId])
  @@index([categoryId])
  @@map("document_categories")
}

model Document {
  id                     String              @id @default(uuid())
  userId                 String
  folderId               String?
  filename               String
  displayTitle           String?             // AI-generated human-readable title
  encryptedFilename      String
  fileSize               Int
  mimeType               String
  fileHash               String
  status                 String              @default("processing")
  parentVersionId        String?
  isEncrypted            Boolean             @default(false)
  encryptionSalt         String?
  encryptionIV           String?
  encryptionAuthTag      String?
  filenameEncrypted      String?
  extractedTextEncrypted String?
  renderableContent      String?
  language               String              @default("english")  // Detected language for BM25 search

  // KODA FIX: Embedding tracking fields
  embeddingsGenerated    Boolean             @default(false)  // Track if embeddings were successfully generated
  chunksCount            Int?                @default(0)       // Track number of chunks/embeddings stored
  error                  String?             @db.Text          // Store error message if processing failed
  createdAt              DateTime            @default(now())
  updatedAt              DateTime            @updatedAt
  categories             DocumentCategory[]
  chunks                 DocumentChunk[]     // KODA FIX: For BM25 keyword search
  embeddings             DocumentEmbedding[]
  metadata               DocumentMetadata?
  summaries              DocumentSummary[]
  tags                   DocumentTag[]
  folder                 Folder?             @relation(fields: [folderId], references: [id], onDelete: Cascade)
  parentVersion          Document?           @relation("DocumentVersions", fields: [parentVersionId], references: [id])
  versions               Document[]          @relation("DocumentVersions")
  user                   User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  generatedDocument      GeneratedDocument?

  // Analytics relations
  processingMetrics      DocumentProcessingMetrics?

  @@index([userId])
  @@index([folderId])
  @@index([parentVersionId])
  @@index([userId, status])
  @@index([status])
  @@index([mimeType])
  @@index([userId, createdAt])
  @@index([userId, updatedAt])
  @@index([folderId, status])
  @@index([userId, folderId, status])
  @@index([filename])
  @@index([userId, filename])
  @@index([fileHash])
  @@index([userId, fileHash, filename])
  @@index([language])
  @@index([userId, language])
  @@map("documents")
}

model DocumentMetadata {
  id                       String    @id @default(uuid())
  documentId               String    @unique
  extractedText            String?
  ocrConfidence            Float?
  pageCount                Int?
  wordCount                Int?
  characterCount           Int?
  thumbnailUrl             String?
  entities                 String?
  classification           String?
  classificationConfidence Float?    // Confidence score for document type classification
  domain                   String?   // Document domain (legal, medical, financial, etc.)
  domainConfidence         Float?    // Confidence score for domain classification
  summary                  String?
  author                   String?
  creationDate             DateTime?
  modificationDate         DateTime?
  language                 String?
  topics                   String?
  keyEntities              String?
  hasSignature             Boolean   @default(false)
  hasTables                Boolean   @default(false)
  hasImages                Boolean   @default(false)
  markdownContent          String?
  markdownUrl              String?
  markdownStructure        String?
  sheetCount               Int?
  slideCount               Int?
  slidesData               String?
  pptxMetadata             String?
  slideGenerationStatus    String?   @default("pending")
  slideGenerationError     String?
  createdAt                DateTime  @default(now())
  updatedAt                DateTime  @updatedAt
  document                 Document  @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@map("document_metadata")
}

// ============================================================================
// KODA FIX: DocumentChunk model for BM25 keyword search
// ============================================================================
// This model stores document text chunks for full-text search (BM25)
// Required for hybrid retrieval (vector + keyword search)
model DocumentChunk {
  id          String   @id @default(uuid())
  documentId  String
  chunkIndex  Int      // Order of chunk in document
  text        String   // Chunk text content
  page        Int?     // Page number if applicable
  startChar   Int?     // Start character position in original document
  endChar     Int?     // End character position in original document
  embedding   Bytes?   // Optional: store embedding vector for local search
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  document    Document @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@index([documentId])
  @@index([documentId, chunkIndex])
  @@index([documentId, page])
  @@map("document_chunks")
}

model Tag {
  id        String        @id @default(uuid())
  userId    String
  name      String
  color     String?
  createdAt DateTime      @default(now())
  documents DocumentTag[]
  user      User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, name])
  @@index([userId])
  @@map("tags")
}

model DocumentTag {
  id         String   @id @default(uuid())
  documentId String
  tagId      String
  createdAt  DateTime @default(now())
  document   Document @relation(fields: [documentId], references: [id], onDelete: Cascade)
  tag        Tag      @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@unique([documentId, tagId])
  @@index([documentId])
  @@index([tagId])
  @@map("document_tags")
}

model VerificationCode {
  id        String   @id @default(uuid())
  userId    String
  type      String
  code      String
  expiresAt DateTime
  isUsed    Boolean  @default(false)
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([code])
  @@map("verification_codes")
}

model PendingUser {
  id                 String   @id @default(uuid())
  email              String   @unique
  passwordHash       String
  salt               String
  firstName          String?
  lastName           String?
  phoneNumber        String?
  emailCode          String?
  phoneCode          String?
  emailVerified      Boolean  @default(false)
  phoneVerified      Boolean  @default(false)
  expiresAt          DateTime
  createdAt          DateTime @default(now())
  recoveryKeyHash    String?
  masterKeyEncrypted String?

  @@index([email])
  @@map("pending_users")
}

model Conversation {
  id                String        @id @default(uuid())
  userId            String
  title             String        @default("New Chat")
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt
  titleEncrypted    String?
  encryptionSalt    String?
  encryptionIV      String?
  encryptionAuthTag String?
  contextType       String?
  contextId         String?
  contextName       String?
  contextMeta       Json?
  scopeDescription  String?
  scopeDocumentIds  String[]      @default([])
  deletedAt         DateTime?
  isDeleted         Boolean       @default(false)
  isPinned          Boolean       @default(false)
  summary           String?

  // Memory Engine 3.0: Store document list shown to user for reference resolution
  documentList      Json?         // Array of {id, name, type} for "the first one" resolution
  lastDocumentId    String?       // Last explicitly referenced document ID

  chatContexts      ChatContext[]
  user              User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  messages          Message[]

  // Analytics relations
  feedback          ConversationFeedback[]
  metrics           ConversationMetrics?
  ragQueries        RAGQueryMetrics[]

  @@index([userId])
  @@index([contextType, contextId])
  @@index([userId, updatedAt])
  @@index([userId, isDeleted, isPinned, updatedAt])
  @@map("conversations")
}

model Message {
  id                String              @id @default(uuid())
  conversationId    String
  role              String
  content           String
  metadata          String?
  createdAt         DateTime            @default(now())
  isEncrypted       Boolean             @default(false)
  encryptionSalt    String?
  encryptionIV      String?
  encryptionAuthTag String?
  isDocument        Boolean             @default(false)
  documentTitle     String?
  documentFormat    String?
  markdownContent   String?
  calculationResult Json?
  contextEntities   Json?

  conversation      Conversation        @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  // Analytics relations
  feedback          ConversationFeedback[]
  ragMetrics        RAGQueryMetrics?

  @@index([conversationId])
  @@index([isDocument])
  @@index([conversationId, createdAt])
  @@map("messages")
}

model Reminder {
  id            String         @id @default(uuid())
  userId        String
  title         String
  description   String?
  dueDate       DateTime
  isCompleted   Boolean        @default(false)
  notified      Boolean        @default(false)
  documentId    String?
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt

  user          User           @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([dueDate])
  @@map("reminders")
}

model DocumentSummary {
  id          String   @id @default(uuid())
  documentId  String
  summary     String
  summaryType String   @default("standard")
  createdAt   DateTime @default(now())
  document    Document @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@index([documentId])
  @@map("document_summaries")
}

model AuditLog {
  id        String   @id @default(uuid())
  userId    String?
  action    String
  resource  String?
  ipAddress String?
  userAgent String?
  status    String
  details   String?
  createdAt DateTime @default(now())
  user      User?    @relation(fields: [userId], references: [id])

  @@index([userId])
  @@index([action])
  @@index([createdAt])
  @@map("audit_logs")
}

model UserPreferences {
  id                        String   @id @default(uuid())
  userId                    String   @unique
  emailNotificationsEnabled Boolean  @default(true)
  emailNotificationTypes    String?
  notificationFrequency     String   @default("immediate")
  createdAt                 DateTime @default(now())
  updatedAt                 DateTime @updatedAt
  user                      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_preferences")
}

model DocumentEntity {
  id              String   @id @default(uuid())
  documentId      String
  entityType      String
  value           String
  normalizedValue String
  pageNumber      Int?     // Page number if applicable
  textIndex       Int      // Position in text
  context         String   // Surrounding text context
  confidence      Float    @default(1.0) // Extraction confidence score
  metadata        String?  // Additional metadata as JSON
  createdAt       DateTime @default(now())

  @@index([documentId, entityType])
  @@index([documentId])
  @@index([entityType])
  @@index([value])
  @@index([normalizedValue])
  @@index([confidence])
  @@map("document_entities")
}

model DocumentKeyword {
  id               String   @id @default(uuid())
  documentId       String
  word             String
  count            Int
  tfIdf            Float?   // TF-IDF score for keyword importance
  isDomainSpecific Boolean  @default(false) // Whether this is a domain-specific keyword
  createdAt        DateTime @default(now())

  @@index([documentId])
  @@index([word])
  @@index([documentId, tfIdf])
  @@map("document_keywords")
}

model DocumentEmbedding {
  // Primary key & identifiers
  id         String   @id @default(uuid())
  documentId String
  userId     String?  @map("user_id")  // For multi-tenant filtering

  // Chunk identity (order & location)
  chunkIndex  Int
  pageNumber  Int?    @map("page_number")  // Page number (extracted from metadata)
  sectionName String? @map("section_name") // Section name (extracted from metadata)

  // Content fields (keeping old fields for backward compatibility during transition)
  content    String                    @db.Text  // Legacy - will be removed
  chunkText  String? @map("chunk_text") @db.Text  // New: Chunk text content
  embedding  String                    @db.Text  // Legacy - stored in Pinecone
  metadata   String                    @db.Text  // Legacy - data extracted to columns

  // New content fields
  microSummary   String? @map("micro_summary") @db.Text  // 1-2 sentence purpose explanation
  chunkType      String? @map("chunk_type")              // From chunkClassifier (legal_clause, diagnosis, etc.)

  // Pinecone & embedding info
  pineconeNamespace String? @map("pinecone_namespace")  // Org/user scoping (e.g., "user-123")
  embeddingModel    String? @map("embedding_model")     // e.g., "text-embedding-3-large"

  // BM25 / Full-text search
  contentTsv   Unsupported("tsvector")? // Legacy tsvector
  searchVector Unsupported("tsvector")? @map("search_vector") // New tsvector for BM25

  // Timestamps
  createdAt  DateTime @default(now())
  updatedAt  DateTime? @map("updated_at")

  // Relationships
  document   Document @relation(fields: [documentId], references: [id], onDelete: Cascade)

  // Indexes
  @@index([documentId])
  @@index([documentId, chunkIndex])
  @@index([userId])
  @@index([chunkType])
  @@index([documentId, sectionName])
  @@index([documentId, pageNumber])
  @@index([pineconeNamespace])
  @@index([userId, documentId])
  @@map("document_embeddings")
}

model TerminologyMap {
  id        String   @id @default(uuid())
  userId    String
  term      String
  synonyms  String
  domain    String
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, term, domain])
  @@index([userId])
  @@index([term])
  @@index([domain])
  @@map("terminology_maps")
}

model ChatContext {
  id              String       @id @default(uuid())
  conversationId  String
  messageId       String?
  sourceDocuments String
  webSources      String?
  searchQuery     String?
  expandedTerms   String?
  createdAt       DateTime     @default(now())
  conversation    Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@index([conversationId])
  @@index([messageId])
  @@map("chat_contexts")
}

model DocumentShare {
  id              String    @id @default(uuid())
  documentId      String
  ownerId         String
  sharedWithId    String
  permissionLevel String    @default("viewer")
  canDownload     Boolean   @default(true)
  canShare        Boolean   @default(false)
  canDelete       Boolean   @default(false)
  expiresAt       DateTime?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  owner           User      @relation("Owner", fields: [ownerId], references: [id], onDelete: Cascade)
  sharedWith      User      @relation("SharedWith", fields: [sharedWithId], references: [id], onDelete: Cascade)

  @@unique([documentId, sharedWithId])
  @@index([documentId])
  @@index([ownerId])
  @@index([sharedWithId])
  @@map("document_shares")
}

model APIUsage {
  id                String   @id @default(uuid())
  userId            String
  month             String
  geminiTokensUsed  Int      @default(0)
  embeddingRequests Int      @default(0)
  chatRequests      Int      @default(0)
  costUSD           Float    @default(0.0)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  @@unique([userId, month])
  @@index([userId])
  @@index([month])
  @@map("api_usage")
}

model APIKey {
  id          String    @id @default(uuid())
  userId      String
  name        String
  keyHash     String    @unique
  keyPreview  String
  scopes      String
  expiresAt   DateTime?
  lastUsedAt  DateTime?
  isActive    Boolean   @default(true)
  rateLimit   Int       @default(1000)
  usageCount  Int       @default(0)
  windowStart DateTime  @default(now())
  ipWhitelist String?
  userAgent   String?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@index([userId])
  @@index([keyHash])
  @@index([isActive])
  @@map("api_keys")
}

model GeneratedDocument {
  id                String                @id @default(uuid())
  userId            String
  documentId        String                @unique
  generationType    String
  conversationId    String?
  isTemporary       Boolean               @default(true)
  expiresAt         DateTime?
  sourceDocumentIds String
  generationPrompt  String?
  renderableContent String
  metadata          String?
  generatedAt       DateTime              @default(now())
  savedAt           DateTime?

  document          Document              @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([documentId])
  @@index([generationType])
  @@index([conversationId])
  @@index([isTemporary])
  @@index([expiresAt])
  @@map("generated_documents")
}

model ExcelSheet {
  id          String      @id @default(uuid())
  documentId  String
  sheetIndex  Int
  sheetName   String
  rowCount    Int
  columnCount Int
  metadata    String?
  cachedAt    DateTime    @default(now())
  expiresAt   DateTime
  cells       ExcelCell[]

  @@unique([documentId, sheetIndex])
  @@index([documentId])
  @@index([expiresAt])
  @@map("excel_sheets")
}

model ExcelCell {
  id       String     @id @default(uuid())
  sheetId  String
  rowIndex Int
  colIndex Int
  value    String?
  formula  String?
  dataType String
  style    String?
  cachedAt DateTime   @default(now())
  sheet    ExcelSheet @relation(fields: [sheetId], references: [id], onDelete: Cascade)

  @@unique([sheetId, rowIndex, colIndex])
  @@index([sheetId])
  @@map("excel_cells")
}

model ActionHistory {
  id           String   @id @default(uuid())
  userId       String
  actionType   String
  targetPath   String
  previousPath String?
  fileContent  String?
  fileType     String?
  canUndo      Boolean  @default(true)
  canRedo      Boolean  @default(false)
  timestamp    DateTime @default(now())
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([canUndo])
  @@index([canRedo])
  @@index([timestamp])
  @@map("action_history")
}

model UserProfile {
  id             String   @id @default(uuid())
  userId         String   @unique
  name           String?
  role           String?
  organization   String?
  expertiseLevel String?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("user_profiles")
}

model UserPreference {
  id              String   @id @default(uuid())
  userId          String
  preferenceType  String
  preferenceValue String
  confidence      Float    @default(0.5)
  evidence        String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([userId, preferenceType])
  @@map("user_preferences_memory")
}

model ConversationTopic {
  id           String   @id @default(uuid())
  userId       String
  topicSummary String
  firstSeen    DateTime
  lastSeen     DateTime
  frequency    Int      @default(1)
  confidence   Float    @default(0.5)
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([userId, lastSeen])
  @@map("conversation_topics")
}

model Memory {
  id           String        @id @default(cuid())
  userId       String
  section      MemorySection
  content      String
  importance   Int           @default(5)
  createdAt    DateTime      @default(now())
  lastAccessed DateTime      @default(now())
  accessCount  Int           @default(0)
  source       String?
  metadata     Json?
  user         User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, section])
  @@index([userId, importance])
  @@index([lastAccessed])
  @@map("memories")
}

model MethodologyKnowledge {
  id                String   @id @default(uuid())
  userId            String
  name              String
  aliases           String?
  definition        String?
  howItWorks        String?
  whyUsed           String?
  limitations       String?
  useCases          String?
  examples          String?
  relatedMethods    String?
  parentMethod      String?
  childMethods      String?
  sourceDocumentIds String?
  documentCount     Int      @default(1)
  extractedFrom     String?
  confidence        Float    @default(0.5)
  isVerified        Boolean  @default(false)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  lastAccessedAt    DateTime @default(now())
  accessCount       Int      @default(0)

  @@unique([userId, name])
  @@index([userId])
  @@index([name])
  @@index([userId, name])
  @@index([confidence])
  @@index([documentCount])
  @@map("methodology_knowledge")
}

model DomainKnowledge {
  id                String                @id @default(uuid())
  userId            String
  term              String
  normalizedTerm    String
  domain            String
  definition        String?
  formula           String?
  interpretation    String?
  usageContext      String?
  examples          String?
  relatedTerms      String?
  parentTerm        String?
  childTerms        String?
  synonyms          String?
  sourceDocumentIds String?
  documentCount     Int                   @default(1)
  extractedContext  String?
  confidence        Float                 @default(0.5)
  isVerified        Boolean               @default(false)
  createdAt         DateTime              @default(now())
  updatedAt         DateTime              @updatedAt
  lastAccessedAt    DateTime              @default(now())
  accessCount       Int                   @default(0)
  outgoingRelations ConceptRelationship[] @relation("FromConcept")
  incomingRelations ConceptRelationship[] @relation("ToConcept")
  user              User                  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, normalizedTerm, domain])
  @@index([userId])
  @@index([term])
  @@index([normalizedTerm])
  @@index([domain])
  @@index([userId, domain])
  @@map("domain_knowledge")
}

model ConceptRelationship {
  id                String          @id @default(uuid())
  userId            String
  fromConceptId     String
  toConceptId       String
  relationshipType  String
  strength          Float           @default(0.5)
  description       String?
  sourceDocumentIds String?
  documentCount     Int             @default(1)
  createdAt         DateTime        @default(now())
  fromConcept       DomainKnowledge @relation("FromConcept", fields: [fromConceptId], references: [id], onDelete: Cascade)
  toConcept         DomainKnowledge @relation("ToConcept", fields: [toConceptId], references: [id], onDelete: Cascade)

  @@unique([fromConceptId, toConceptId, relationshipType])
  @@index([userId])
  @@index([fromConceptId])
  @@index([toConceptId])
  @@index([relationshipType])
  @@map("concept_relationships")
}

model CausalRelationship {
  id                String   @id @default(uuid())
  userId            String
  effect            String
  causes            String
  evidence          String?
  context           String?
  mechanism         String?
  domain            String?
  causalType        String?
  sourceDocumentIds String?
  documentCount     Int      @default(1)
  extractedPatterns String?
  confidence        Float    @default(0.5)
  isVerified        Boolean  @default(false)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  @@index([userId])
  @@index([userId, domain])
  @@index([confidence])
  @@map("causal_relationships")
}

model ComparativeData {
  id                    String   @id @default(uuid())
  userId                String
  conceptA              String
  conceptB              String
  attributes            String
  comparativeStatements String?
  keyInsight            String?
  similarities          String?
  differences           String?
  sourceDocumentIds     String?
  documentCount         Int      @default(1)
  confidence            Float    @default(0.5)
  isVerified            Boolean  @default(false)
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  @@unique([userId, conceptA, conceptB])
  @@index([userId])
  @@index([conceptA])
  @@index([conceptB])
  @@map("comparative_data")
}

model Presentation {
  id                 String    @id @default(uuid())
  userId             String
  title              String
  description        String?
  status             String    @default("draft")
  colorPalette       String?
  typography         String?
  aestheticDirection String?
  totalSlides        Int       @default(0)
  viewCount          Int       @default(0)
  lastViewedAt       DateTime?
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt
  user               User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  slides             Slide[]

  @@index([userId])
  @@index([status])
  @@index([createdAt])
  @@map("presentations")
}

model Slide {
  id             String       @id @default(uuid())
  presentationId String
  slideNumber    Int
  title          String
  summary        String?
  htmlContent    String
  layout         String
  template       String?
  status         String       @default("pending")
  errorMessage   String?
  generatedAt    DateTime?
  renderTime     Int?
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  presentation   Presentation @relation(fields: [presentationId], references: [id], onDelete: Cascade)

  @@unique([presentationId, slideNumber])
  @@index([presentationId])
  @@index([status])
  @@map("slides")
}

model ConversationChunk {
  id             String   @id @default(uuid())
  conversationId String
  userId         String
  startMessageId String
  endMessageId   String
  messageCount   Int      @default(0)
  content        String
  summary        String
  topics         String[]
  entities       String[]
  keywords       String[]
  vectorId       String?  @unique
  embeddingModel String   @default("text-embedding-004")
  importance     Float    @default(0.5)
  coherence      Float    @default(0.5)
  firstMessageAt DateTime
  lastMessageAt  DateTime
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  @@index([conversationId])
  @@index([userId])
  @@index([vectorId])
  @@index([conversationId, lastMessageAt])
  @@index([userId, lastMessageAt])
  @@map("conversation_chunks")
}

model ConversationIndex {
  id                    String   @id @default(uuid())
  conversationId        String   @unique
  userId                String
  title                 String
  summary               String
  mainTopics            String[]
  keyEntities           String[]
  keywords              String[]
  messageCount          Int      @default(0)
  chunkCount            Int      @default(0)
  userMessageCount      Int      @default(0)
  assistantMessageCount Int      @default(0)
  vectorId              String?  @unique
  embeddingModel        String   @default("text-embedding-004")
  firstMessageAt        DateTime
  lastMessageAt         DateTime
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  @@index([userId])
  @@index([vectorId])
  @@index([userId, lastMessageAt])
  @@map("conversation_indexes")
}

model ConversationContextState {
  id                   String    @id @default(uuid())
  conversationId       String    @unique
  userId               String
  recentMessageIds     String[]
  retrievedChunkIds    String[]
  memoryIds            String[]
  totalTokens          Int       @default(0)
  recentMessagesTokens Int       @default(0)
  chunksTokens         Int       @default(0)
  memoriesTokens       Int       @default(0)
  documentsTokens      Int       @default(0)
  isCompressed         Boolean   @default(false)
  compressionLevel     Int       @default(0)
  lastCompressedAt     DateTime?
  lastQuery            String?
  lastQueryEmbedding   Json?
  updatedAt            DateTime  @updatedAt

  // New fields for ChatGPT-style conversation intelligence
  currentTopic         String?
  keyEntities          String[]  @default([])
  keyTopics            String[]  @default([])
  summary              String?
  lastMessageCount     Int       @default(0)
  metadata             Json?

  @@index([conversationId])
  @@index([userId])
  @@map("conversation_context_states")
}

model AnalyticsDailyStat {
  id                 String   @id @default(uuid())
  date               DateTime @unique
  totalUsers         Int      @default(0)
  newUsers           Int      @default(0)
  activeUsers        Int      @default(0)
  totalConversations Int      @default(0)
  newConversations   Int      @default(0)
  totalMessages      Int      @default(0)
  userMessages       Int      @default(0)
  assistantMessages  Int      @default(0)
  totalDocuments     Int      @default(0)
  newDocuments       Int      @default(0)
  storageUsedBytes   BigInt   @default(0)
  errorCount         Int      @default(0)
  avgResponseTimeMs  Int      @default(0)
  estimatedCostUSD   Float    @default(0)
  geminiApiCalls     Int      @default(0)
  embeddingCalls     Int      @default(0)
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  @@index([date])
  @@map("analytics_daily_stats")
}

model AnalyticsUserActivity {
  id                   String    @id @default(uuid())
  userId               String
  date                 DateTime
  sessionsCount        Int       @default(0)
  messagesSent         Int       @default(0)
  documentsUploaded    Int       @default(0)
  conversationsCreated Int       @default(0)
  ragQueriesCount      Int       @default(0)
  totalActiveMinutes   Int       @default(0)
  lastActiveAt         DateTime?
  featuresUsed         String[]  @default([])
  createdAt            DateTime  @default(now())
  updatedAt            DateTime  @updatedAt

  @@unique([userId, date])
  @@index([userId])
  @@index([date])
  @@index([userId, date])
  @@map("analytics_user_activity")
}

model AnalyticsSystemHealth {
  id                  String   @id @default(uuid())
  timestamp           DateTime @default(now())
  databaseConnections Int      @default(0)
  databaseSizeBytes   BigInt   @default(0)
  slowQueryCount      Int      @default(0)
  requestsPerMinute   Int      @default(0)
  avgResponseTimeMs   Int      @default(0)
  errorRate           Float    @default(0)
  cpuUsagePercent     Float    @default(0)
  memoryUsagePercent  Float    @default(0)
  diskUsagePercent    Float    @default(0)
  pineconeLatencyMs   Int      @default(0)
  geminiLatencyMs     Int      @default(0)
  s3LatencyMs         Int      @default(0)

  @@index([timestamp])
  @@map("analytics_system_health")
}

model AnalyticsError {
  id              String    @id @default(uuid())
  timestamp       DateTime  @default(now())
  errorType       String
  errorCode       String?
  errorMessage    String
  stackTrace      String?
  endpoint        String?
  method          String?
  userId          String?
  requestBody     String?
  isResolved      Boolean   @default(false)
  resolvedAt      DateTime?
  resolvedBy      String?
  resolution      String?
  fingerprint     String?
  occurrenceCount Int       @default(1)
  firstOccurrence DateTime  @default(now())
  lastOccurrence  DateTime  @default(now())

  @@index([timestamp])
  @@index([errorType])
  @@index([fingerprint])
  @@index([isResolved])
  @@index([userId])
  @@map("analytics_errors")
}

model AdminAuditLog {
  id          String   @id @default(uuid())
  adminUserId String
  timestamp   DateTime @default(now())
  action      String
  resource    String?
  resourceId  String?
  ipAddress   String?
  userAgent   String?
  details     Json?

  @@index([adminUserId])
  @@index([timestamp])
  @@index([action])
  @@map("admin_audit_logs")
}

enum MemorySection {
  USER_PREFERENCES
  WORK_CONTEXT
  PERSONAL_FACTS
  GOALS
  COMMUNICATION_STYLE
  RELATIONSHIPS
}

// ============================================================================
// ANALYTICS DATA MODEL FOR KODA
// Designed to track all critical metrics for production-ready analytics
// ============================================================================

// ----------------------------------------------------------------------------
// 1. USER ENGAGEMENT TRACKING
// ----------------------------------------------------------------------------

model UserSession {
  id            String   @id @default(cuid())
  userId        String
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Session timing
  startedAt     DateTime @default(now())
  endedAt       DateTime?
  duration      Int?     // Duration in seconds (calculated on session end)

  // Session metadata
  ipAddress     String?
  userAgent     String?
  device        String?  // mobile, tablet, desktop
  browser       String?
  os            String?

  // Activity tracking
  pageViews     Int      @default(0)
  actionsCount  Int      @default(0)
  messagesCount Int      @default(0)

  // Session quality
  bounced       Boolean  @default(false) // Left within 30 seconds
  converted     Boolean  @default(false) // Completed a goal

  events        AnalyticsEvent[]

  @@index([userId])
  @@index([startedAt])
  @@map("user_sessions")
}

model AnalyticsEvent {
  id          String   @id @default(cuid())
  sessionId   String?
  session     UserSession? @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  userId      String?
  user        User?    @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Event details
  eventType   String   // page_view, feature_used, button_clicked, etc.
  eventName   String   // Specific event name
  category    String?  // Grouping category

  // Event data (JSON for flexibility)
  properties  Json?    // Custom event properties

  // Timing
  timestamp   DateTime @default(now())
  duration    Int?     // For events with duration (in ms)

  @@index([userId])
  @@index([sessionId])
  @@index([eventType])
  @@index([timestamp])
  @@map("analytics_events")
}

// ----------------------------------------------------------------------------
// 2. CONVERSATION QUALITY METRICS
// ----------------------------------------------------------------------------

model ConversationFeedback {
  id              String   @id @default(cuid())
  conversationId  String
  conversation    Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  messageId       String?
  message         Message? @relation(fields: [messageId], references: [id], onDelete: Cascade)
  userId          String
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Feedback type
  feedbackType    String   // thumbs_up, thumbs_down, rating, comment
  rating          Int?     // 1-5 star rating (if applicable)
  sentiment       String?  // positive, negative, neutral

  // Detailed feedback
  comment         String?  @db.Text
  categories      String[] // helpful, accurate, fast, etc.

  // Context
  wasHelpful      Boolean?
  hadSources      Boolean  @default(false)
  sourceCount     Int      @default(0)

  createdAt       DateTime @default(now())

  @@index([conversationId])
  @@index([userId])
  @@index([feedbackType])
  @@index([createdAt])
  @@map("conversation_feedback")
}

model ConversationMetrics {
  id              String   @id @default(cuid())
  conversationId  String   @unique
  conversation    Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  // Timing metrics
  startedAt       DateTime
  endedAt         DateTime?
  duration        Int?     // Total duration in seconds

  // Message metrics
  totalMessages   Int      @default(0)
  userMessages    Int      @default(0)
  assistantMessages Int    @default(0)

  // Quality metrics
  completed       Boolean  @default(false)
  abandoned       Boolean  @default(false)
  hadFallback     Boolean  @default(false)
  fallbackCount   Int      @default(0)

  // RAG metrics
  ragQueriesCount Int      @default(0)
  sourcesUsedCount Int     @default(0)
  avgRelevanceScore Float?

  // User satisfaction
  userRating      Int?     // 1-5 stars
  userFeedback    String?  // positive, negative, neutral

  updatedAt       DateTime @updatedAt

  @@index([startedAt])
  @@index([completed])
  @@map("conversation_metrics")
}

// ----------------------------------------------------------------------------
// 3. DOCUMENT PROCESSING METRICS
// ----------------------------------------------------------------------------

model DocumentProcessingMetrics {
  id                String   @id @default(cuid())
  documentId        String   @unique
  document          Document @relation(fields: [documentId], references: [id], onDelete: Cascade)

  // Upload metrics
  uploadStartedAt   DateTime
  uploadCompletedAt DateTime?
  uploadDuration    Int?     // Seconds
  uploadFailed      Boolean  @default(false)
  uploadError       String?  @db.Text

  // Processing metrics
  processingStartedAt   DateTime?
  processingCompletedAt DateTime?
  processingDuration    Int?     // Seconds
  processingFailed      Boolean  @default(false)
  processingError       String?  @db.Text

  // Text extraction
  textExtractionMethod  String?  // pdf-parse, tesseract, mistral-ocr, etc.
  textExtractionSuccess Boolean  @default(false)
  textExtractionTime    Int?     // Milliseconds
  textLength            Int?     // Characters extracted

  // OCR metrics (if applicable)
  ocrUsed           Boolean  @default(false)
  ocrSuccess        Boolean  @default(false)
  ocrConfidence     Float?   // 0-1 confidence score
  ocrTime           Int?     // Milliseconds

  // Embedding metrics
  embeddingStartedAt    DateTime?
  embeddingCompletedAt  DateTime?
  embeddingDuration     Int?     // Seconds
  embeddingsCreated     Int      @default(0)
  chunksCreated         Int      @default(0)

  // Access metrics
  timesQueried      Int      @default(0)
  lastQueriedAt     DateTime?

  updatedAt         DateTime @updatedAt

  @@index([documentId])
  @@index([uploadStartedAt])
  @@map("document_processing_metrics")
}

// ----------------------------------------------------------------------------
// 4. RAG PERFORMANCE METRICS
// ----------------------------------------------------------------------------

model RAGQueryMetrics {
  id              String   @id @default(cuid())
  conversationId  String?
  conversation    Conversation? @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  messageId       String?  @unique
  message         Message? @relation(fields: [messageId], references: [id], onDelete: Cascade)
  userId          String
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Query details
  query           String   @db.Text
  queryLanguage   String?  // en, es, pt, etc.

  // Retrieval method
  retrievalMethod String   // hybrid, pinecone_only, bm25_only
  usedBM25        Boolean  @default(false)
  usedPinecone    Boolean  @default(false)

  // Performance timing
  startedAt       DateTime @default(now())
  completedAt     DateTime?
  totalLatency    Int?     // Total time in ms
  embeddingLatency Int?    // Time to generate query embedding
  bm25Latency     Int?     // Time for BM25 search
  pineconeLatency Int?     // Time for Pinecone search
  llmLatency      Int?     // Time for LLM response

  // Retrieval results
  chunksRetrieved Int      @default(0)
  bm25Results     Int      @default(0)
  pineconeResults Int      @default(0)
  documentsUsed   Int      @default(0)

  // Quality metrics
  topScore        Float?   // Highest relevance score
  avgScore        Float?   // Average relevance score
  minRelevanceScore Float? // Threshold used
  passedThreshold Boolean  @default(false)

  // Outcome
  needsRefinement Boolean  @default(false)
  refinementReason String? // low_relevance, no_results, etc.
  hadFallback     Boolean  @default(false)
  responseGenerated Boolean @default(false)

  // Source diversity
  uniqueDocuments Int      @default(0)
  sourceCoverage  Float?   // 0-1 score for source diversity

  @@index([userId])
  @@index([conversationId])
  @@index([startedAt])
  @@index([retrievalMethod])
  @@map("rag_query_metrics")
}

// ----------------------------------------------------------------------------
// 5. API PERFORMANCE METRICS
// ----------------------------------------------------------------------------

model APIPerformanceLog {
  id            String   @id @default(cuid())

  // API details
  service       String   // openai, pinecone, s3, gemini, etc.
  endpoint      String   // chat/completions, query, upload, etc.
  method        String   // GET, POST, PUT, DELETE

  // Request details
  requestSize   Int?     // Bytes
  requestData   Json?    // Sanitized request data

  // Response details
  responseSize  Int?     // Bytes
  statusCode    Int
  success       Boolean
  errorMessage  String?  @db.Text
  errorCode     String?

  // Performance
  startedAt     DateTime @default(now())
  completedAt   DateTime?
  latency       Int?     // Milliseconds

  // Rate limiting
  rateLimitHit  Boolean  @default(false)
  retryCount    Int      @default(0)

  // Cost tracking (if applicable)
  tokensUsed    Int?
  estimatedCost Float?

  // Context
  userId        String?
  conversationId String?

  @@index([service])
  @@index([startedAt])
  @@index([success])
  @@index([rateLimitHit])
  @@map("api_performance_logs")
}

// ----------------------------------------------------------------------------
// 6. REAL-TIME SYSTEM HEALTH SNAPSHOTS
// ----------------------------------------------------------------------------

model SystemHealthSnapshot {
  id                String   @id @default(cuid())

  // Timestamp
  timestamp         DateTime @default(now())

  // User activity
  onlineUsers       Int      @default(0)
  activeConversations Int    @default(0)

  // System load
  cpuUsage          Float?   // Percentage
  memoryUsage       Float?   // Percentage
  diskUsage         Float?   // Percentage

  // API activity
  apiRequestsPerSec Float?
  avgResponseTime   Float?   // Milliseconds
  errorRate         Float?   // Percentage

  // Database
  dbConnections     Int?
  dbQueryTime       Float?   // Average in ms

  // Queue status
  queuedJobs        Int      @default(0)
  processingJobs    Int      @default(0)
  failedJobs        Int      @default(0)

  @@index([timestamp])
  @@map("system_health_snapshots")
}

// ----------------------------------------------------------------------------
// 7. BUSINESS METRICS - USER LIFETIME VALUE
// ----------------------------------------------------------------------------

model UserLifetimeValue {
  id              String   @id @default(cuid())
  userId          String   @unique
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Engagement metrics
  totalSessions   Int      @default(0)
  totalMessages   Int      @default(0)
  totalDocuments  Int      @default(0)
  totalConversations Int   @default(0)

  // Time metrics
  totalTimeSpent  Int      @default(0) // Seconds
  avgSessionDuration Float?
  daysSinceSignup Int?
  lastActiveAt    DateTime?

  // Retention
  isActive        Boolean  @default(true)
  isChurned       Boolean  @default(false)
  churnedAt       DateTime?
  churnReason     String?

  // Value metrics
  subscriptionTier String?
  lifetimeRevenue Float?   @default(0)
  estimatedValue  Float?

  // Feature usage
  featuresUsed    String[] // List of features used
  featureAdoptionRate Float?

  updatedAt       DateTime @updatedAt

  @@index([userId])
  @@index([isActive])
  @@index([isChurned])
  @@map("user_lifetime_value")
}

// ----------------------------------------------------------------------------
// 8. FEATURE USAGE TRACKING
// ----------------------------------------------------------------------------

model FeatureUsageLog {
  id          String   @id @default(cuid())
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Feature details
  featureName String   // rag_query, document_upload, memory_usage, etc.
  featureCategory String? // chat, documents, settings, etc.

  // Usage details
  usedAt      DateTime @default(now())
  duration    Int?     // Milliseconds (if applicable)
  success     Boolean  @default(true)
  errorMessage String? @db.Text

  // Context
  sessionId   String?
  conversationId String?

  // Metadata
  metadata    Json?    // Additional feature-specific data

  @@index([userId])
  @@index([featureName])
  @@index([usedAt])
  @@map("feature_usage_logs")
}

// ----------------------------------------------------------------------------
// 9. TOKEN USAGE TRACKING (LLM Cost Analytics)
// ----------------------------------------------------------------------------

model TokenUsage {
  id              String   @id @default(cuid())

  // Request context
  userId          String?
  conversationId  String?
  messageId       String?

  // Model information
  model           String   // gemini-2.5-flash, gemini-2.0-flash, text-embedding-004, etc.
  provider        String   // gemini, openai, anthropic

  // Token counts
  inputTokens     Int      @default(0)
  outputTokens    Int      @default(0)
  totalTokens     Int      @default(0)

  // Cost calculation
  inputCost       Float    @default(0)  // USD
  outputCost      Float    @default(0)  // USD
  totalCost       Float    @default(0)  // USD

  // Request metadata
  requestType     String   // chat, embedding, summary, classification, etc.
  latencyMs       Int?     // Response time in milliseconds
  success         Boolean  @default(true)
  errorMessage    String?  @db.Text

  // Caching
  wasCached       Boolean  @default(false)
  cacheHit        Boolean  @default(false)

  // Timestamps
  createdAt       DateTime @default(now())

  @@index([userId])
  @@index([conversationId])
  @@index([model])
  @@index([provider])
  @@index([requestType])
  @@index([createdAt])
  @@map("token_usage")
}

// ----------------------------------------------------------------------------
// 10. DAILY ANALYTICS AGGREGATION
// ----------------------------------------------------------------------------

model DailyAnalyticsAggregate {
  id                    String   @id @default(cuid())
  date                  DateTime @unique @db.Date

  // User metrics
  totalUsers            Int      @default(0)
  newUsers              Int      @default(0)
  activeUsers           Int      @default(0)
  returningUsers        Int      @default(0)

  // Session metrics
  totalSessions         Int      @default(0)
  avgSessionDuration    Int      @default(0)  // seconds
  bounceRate            Float    @default(0)  // percentage

  // Conversation metrics
  totalConversations    Int      @default(0)
  newConversations      Int      @default(0)
  avgMessagesPerConversation Float @default(0)

  // Message metrics
  totalMessages         Int      @default(0)
  userMessages          Int      @default(0)
  assistantMessages     Int      @default(0)
  avgResponseTime       Int      @default(0)  // milliseconds

  // Document metrics
  totalDocuments        Int      @default(0)
  newDocuments          Int      @default(0)
  documentsProcessed    Int      @default(0)
  totalStorageBytes     BigInt   @default(0)

  // RAG metrics
  totalRagQueries       Int      @default(0)
  avgRagLatency         Int      @default(0)  // milliseconds
  ragSuccessRate        Float    @default(0)  // percentage
  fallbackRate          Float    @default(0)  // percentage

  // Token & cost metrics
  totalInputTokens      Int      @default(0)
  totalOutputTokens     Int      @default(0)
  totalTokenCost        Float    @default(0)  // USD
  geminiCalls           Int      @default(0)
  embeddingCalls        Int      @default(0)

  // Error metrics
  totalErrors           Int      @default(0)
  errorRate             Float    @default(0)  // percentage

  // Feature usage
  topFeatures           Json?    // Array of {feature, count}

  // Feedback metrics
  positiveRatings       Int      @default(0)
  negativeRatings       Int      @default(0)
  satisfactionRate      Float    @default(0)  // percentage

  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  @@index([date])
  @@map("daily_analytics_aggregates")
}

// ============================================================================
// ENHANCED RAG SYSTEM - CONVERSATION STATE
// Used by rollingConversationSummary.service.ts for conversation continuity
// ============================================================================

model ConversationState {
  id                      String   @id @default(cuid())
  conversationId          String   @unique
  userId                  String

  // Conversation context tracking
  userGoal                String   @default("Exploring documents")
  currentDocument         String?  // Current document being discussed
  currentTopic            String   @default("General inquiry")
  knownSections           String[] @default([])  // Sections that have been discussed
  knownDocuments          String[] @default([])  // Documents that have been mentioned

  // Language tracking (detected from first message, persisted for consistency)
  language                String   @default("en")  // Language code: en, pt, es, fr

  // Rolling summary
  summary                 String   @default("Conversation just started.")
  lastSummaryAt           DateTime @default(now())
  turnsSinceLastSummary   Int      @default(0)

  // Timestamps
  createdAt               DateTime @default(now())
  updatedAt               DateTime @updatedAt

  @@index([conversationId])
  @@index([userId])
  @@index([turnsSinceLastSummary])
  @@map("conversation_states")
}
