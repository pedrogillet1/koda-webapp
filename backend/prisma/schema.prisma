generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_DATABASE_URL")
}

model User {
  id                    String                @id @default(uuid())
  email                 String                @unique
  firstName             String?
  lastName              String?
  profileImage          String?
  passwordHash          String?
  salt                  String?
  googleId              String?               @unique
  appleId               String?               @unique
  phoneNumber           String?               @unique
  isEmailVerified       Boolean               @default(false)
  isPhoneVerified       Boolean               @default(false)
  subscriptionTier      String                @default("free")
  role                  String                @default("user")
  storageUsedBytes      BigInt                @default(0)
  createdAt             DateTime              @default(now())
  updatedAt             DateTime              @updatedAt
  recoveryKeyHash       String?
  masterKeyEncrypted    String?
  actionHistory         ActionHistory[]
  auditLogs             AuditLog[]

  conversationTopics    ConversationTopic[]
  conversations         Conversation[]
  ownedShares           DocumentShare[]       @relation("Owner")
  sharedDocuments       DocumentShare[]       @relation("SharedWith")
  documents             Document[]
  domainKnowledge       DomainKnowledge[]
  folders               Folder[]

  memories              Memory[]

  presentations         Presentation[]
  reminders             Reminder[]
  sessions              Session[]
  tags                  Tag[]
  terminologyMaps       TerminologyMap[]
  twoFactorAuth         TwoFactorAuth?

  userPreferences       UserPreferences?
  preferencesMemory     UserPreference[]
  profile               UserProfile?
  verificationCodes     VerificationCode[]

  @@map("users")
}

model Session {
  id               String   @id @default(uuid())
  userId           String
  refreshTokenHash String
  expiresAt        DateTime
  createdAt        DateTime @default(now())
  lastActivityAt   DateTime @default(now())
  ipAddress        String?
  lastIpAddress    String?
  userAgent        String?
  deviceId         String?
  deviceType       String?
  deviceName       String?
  isActive         Boolean  @default(true)
  isSuspicious     Boolean  @default(false)
  suspicionReason  String?
  country          String?
  city             String?
  user             User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([deviceId])
  @@index([isActive])
  @@map("sessions")
}

model TwoFactorAuth {
  id          String   @id @default(uuid())
  userId      String   @unique
  secret      String
  backupCodes String
  isEnabled   Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("two_factor_auth")
}

model Folder {
  id                String     @id @default(uuid())
  userId            String
  name              String
  description       String?
  emoji             String?
  color             String?
  parentFolderId    String?
  path              String?
  createdAt         DateTime   @default(now())
  updatedAt         DateTime   @updatedAt
  nameEncrypted     String?
  encryptionSalt    String?
  encryptionIV      String?
  encryptionAuthTag String?
  documents         Document[]
  parentFolder      Folder?    @relation("FolderHierarchy", fields: [parentFolderId], references: [id], onDelete: Cascade)
  subfolders        Folder[]   @relation("FolderHierarchy")
  user              User       @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([parentFolderId])
  @@index([path])
  @@index([userId, parentFolderId])
  @@index([parentFolderId, name])
  @@map("folders")
}

model Category {
  id          String             @id @default(uuid())
  userId      String
  name        String
  description String?
  color       String?
  icon        String?
  createdAt   DateTime           @default(now())
  updatedAt   DateTime           @updatedAt
  documents   DocumentCategory[]

  @@unique([userId, name])
  @@index([userId])
  @@map("categories")
}

model DocumentCategory {
  id         String   @id @default(uuid())
  documentId String
  categoryId String
  createdAt  DateTime @default(now())
  category   Category @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  document   Document @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@unique([documentId, categoryId])
  @@index([documentId])
  @@index([categoryId])
  @@map("document_categories")
}

model Document {
  id                     String              @id @default(uuid())
  userId                 String
  folderId               String?
  filename               String
  encryptedFilename      String
  fileSize               Int
  mimeType               String
  fileHash               String
  status                 String              @default("processing")
  parentVersionId        String?
  isEncrypted            Boolean             @default(false)
  encryptionSalt         String?
  encryptionIV           String?
  encryptionAuthTag      String?
  filenameEncrypted      String?
  extractedTextEncrypted String?
  renderableContent      String?
  createdAt              DateTime            @default(now())
  updatedAt              DateTime            @updatedAt
  categories             DocumentCategory[]
  chunks                 DocumentChunk[]     // KODA FIX: For BM25 keyword search
  embeddings             DocumentEmbedding[]
  metadata               DocumentMetadata?
  summaries              DocumentSummary[]
  tags                   DocumentTag[]
  folder                 Folder?             @relation(fields: [folderId], references: [id], onDelete: Cascade)
  parentVersion          Document?           @relation("DocumentVersions", fields: [parentVersionId], references: [id])
  versions               Document[]          @relation("DocumentVersions")
  user                   User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  generatedDocument      GeneratedDocument?

  @@index([userId])
  @@index([folderId])
  @@index([parentVersionId])
  @@index([userId, status])
  @@index([status])
  @@index([mimeType])
  @@index([userId, createdAt])
  @@index([userId, updatedAt])
  @@index([folderId, status])
  @@index([userId, folderId, status])
  @@index([filename])
  @@index([userId, filename])
  @@index([fileHash])
  @@index([userId, fileHash, filename])
  @@map("documents")
}

model DocumentMetadata {
  id                    String    @id @default(uuid())
  documentId            String    @unique
  extractedText         String?
  ocrConfidence         Float?
  pageCount             Int?
  wordCount             Int?
  characterCount        Int?
  thumbnailUrl          String?
  entities              String?
  classification        String?
  summary               String?
  author                String?
  creationDate          DateTime?
  modificationDate      DateTime?
  language              String?
  topics                String?
  keyEntities           String?
  hasSignature          Boolean   @default(false)
  hasTables             Boolean   @default(false)
  hasImages             Boolean   @default(false)
  markdownContent       String?
  markdownUrl           String?
  markdownStructure     String?
  sheetCount            Int?
  slideCount            Int?
  slidesData            String?
  pptxMetadata          String?
  slideGenerationStatus String?   @default("pending")
  slideGenerationError  String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt
  document              Document  @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@map("document_metadata")
}

// ============================================================================
// KODA FIX: DocumentChunk model for BM25 keyword search
// ============================================================================
// This model stores document text chunks for full-text search (BM25)
// Required for hybrid retrieval (vector + keyword search)
model DocumentChunk {
  id          String   @id @default(uuid())
  documentId  String
  chunkIndex  Int      // Order of chunk in document
  text        String   // Chunk text content
  page        Int?     // Page number if applicable
  startChar   Int?     // Start character position in original document
  endChar     Int?     // End character position in original document
  embedding   Bytes?   // Optional: store embedding vector for local search
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  document    Document @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@index([documentId])
  @@index([documentId, chunkIndex])
  @@index([documentId, page])
  @@map("document_chunks")
}

model Tag {
  id        String        @id @default(uuid())
  userId    String
  name      String
  color     String?
  createdAt DateTime      @default(now())
  documents DocumentTag[]
  user      User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, name])
  @@index([userId])
  @@map("tags")
}

model DocumentTag {
  id         String   @id @default(uuid())
  documentId String
  tagId      String
  createdAt  DateTime @default(now())
  document   Document @relation(fields: [documentId], references: [id], onDelete: Cascade)
  tag        Tag      @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@unique([documentId, tagId])
  @@index([documentId])
  @@index([tagId])
  @@map("document_tags")
}

model VerificationCode {
  id        String   @id @default(uuid())
  userId    String
  type      String
  code      String
  expiresAt DateTime
  isUsed    Boolean  @default(false)
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([code])
  @@map("verification_codes")
}

model PendingUser {
  id                 String   @id @default(uuid())
  email              String   @unique
  passwordHash       String
  salt               String
  firstName          String?
  lastName           String?
  phoneNumber        String?
  emailCode          String?
  phoneCode          String?
  emailVerified      Boolean  @default(false)
  phoneVerified      Boolean  @default(false)
  expiresAt          DateTime
  createdAt          DateTime @default(now())
  recoveryKeyHash    String?
  masterKeyEncrypted String?

  @@index([email])
  @@map("pending_users")
}

model Conversation {
  id                String        @id @default(uuid())
  userId            String
  title             String        @default("New Chat")
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt
  titleEncrypted    String?
  encryptionSalt    String?
  encryptionIV      String?
  encryptionAuthTag String?
  contextType       String?
  contextId         String?
  contextName       String?
  contextMeta       Json?
  scopeDescription  String?
  scopeDocumentIds  String[]      @default([])
  deletedAt         DateTime?
  isDeleted         Boolean       @default(false)
  isPinned          Boolean       @default(false)
  summary           String?
  chatContexts      ChatContext[]
  user              User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  messages          Message[]

  @@index([userId])
  @@index([contextType, contextId])
  @@index([userId, updatedAt])
  @@index([userId, isDeleted, isPinned, updatedAt])
  @@map("conversations")
}

model Message {
  id                String              @id @default(uuid())
  conversationId    String
  role              String
  content           String
  metadata          String?
  createdAt         DateTime            @default(now())
  isEncrypted       Boolean             @default(false)
  encryptionSalt    String?
  encryptionIV      String?
  encryptionAuthTag String?
  isDocument        Boolean             @default(false)
  documentTitle     String?
  documentFormat    String?
  markdownContent   String?
  calculationResult Json?
  contextEntities   Json?

  conversation      Conversation        @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@index([conversationId])
  @@index([isDocument])
  @@index([conversationId, createdAt])
  @@map("messages")
}

model Reminder {
  id            String         @id @default(uuid())
  userId        String
  title         String
  description   String?
  dueDate       DateTime
  isCompleted   Boolean        @default(false)
  notified      Boolean        @default(false)
  documentId    String?
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt

  user          User           @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([dueDate])
  @@map("reminders")
}

model DocumentSummary {
  id          String   @id @default(uuid())
  documentId  String
  summary     String
  summaryType String   @default("standard")
  createdAt   DateTime @default(now())
  document    Document @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@index([documentId])
  @@map("document_summaries")
}

model AuditLog {
  id        String   @id @default(uuid())
  userId    String?
  action    String
  resource  String?
  ipAddress String?
  userAgent String?
  status    String
  details   String?
  createdAt DateTime @default(now())
  user      User?    @relation(fields: [userId], references: [id])

  @@index([userId])
  @@index([action])
  @@index([createdAt])
  @@map("audit_logs")
}

model UserPreferences {
  id                        String   @id @default(uuid())
  userId                    String   @unique
  emailNotificationsEnabled Boolean  @default(true)
  emailNotificationTypes    String?
  notificationFrequency     String   @default("immediate")
  createdAt                 DateTime @default(now())
  updatedAt                 DateTime @updatedAt
  user                      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_preferences")
}

model DocumentEntity {
  id              String   @id @default(uuid())
  documentId      String
  entityType      String
  value           String
  normalizedValue String
  pageNumber      Int
  textIndex       Int
  context         String
  metadata        String?
  createdAt       DateTime @default(now())

  @@index([documentId, entityType])
  @@index([documentId])
  @@index([entityType])
  @@index([value])
  @@index([normalizedValue])
  @@map("document_entities")
}

model DocumentKeyword {
  id         String   @id @default(uuid())
  documentId String
  word       String
  count      Int
  createdAt  DateTime @default(now())

  @@index([documentId])
  @@index([word])
  @@map("document_keywords")
}

model DocumentEmbedding {
  id         String                    @id @default(uuid())
  documentId String
  chunkIndex Int
  content    String                    @db.Text
  embedding  String                    @db.Text
  metadata   String                    @db.Text
  createdAt  DateTime                  @default(now())
  // Pre-computed tsvector for full-text search (GIN indexed)
  // Auto-updated by PostgreSQL trigger when content changes
  contentTsv Unsupported("tsvector")?
  document   Document                  @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@index([documentId])
  @@index([documentId, chunkIndex])
  @@map("document_embeddings")
}

model TerminologyMap {
  id        String   @id @default(uuid())
  userId    String
  term      String
  synonyms  String
  domain    String
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, term, domain])
  @@index([userId])
  @@index([term])
  @@index([domain])
  @@map("terminology_maps")
}

model ChatContext {
  id              String       @id @default(uuid())
  conversationId  String
  messageId       String?
  sourceDocuments String
  webSources      String?
  searchQuery     String?
  expandedTerms   String?
  createdAt       DateTime     @default(now())
  conversation    Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@index([conversationId])
  @@index([messageId])
  @@map("chat_contexts")
}

model DocumentShare {
  id              String    @id @default(uuid())
  documentId      String
  ownerId         String
  sharedWithId    String
  permissionLevel String    @default("viewer")
  canDownload     Boolean   @default(true)
  canShare        Boolean   @default(false)
  canDelete       Boolean   @default(false)
  expiresAt       DateTime?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  owner           User      @relation("Owner", fields: [ownerId], references: [id], onDelete: Cascade)
  sharedWith      User      @relation("SharedWith", fields: [sharedWithId], references: [id], onDelete: Cascade)

  @@unique([documentId, sharedWithId])
  @@index([documentId])
  @@index([ownerId])
  @@index([sharedWithId])
  @@map("document_shares")
}

model APIUsage {
  id                String   @id @default(uuid())
  userId            String
  month             String
  geminiTokensUsed  Int      @default(0)
  embeddingRequests Int      @default(0)
  chatRequests      Int      @default(0)
  costUSD           Float    @default(0.0)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  @@unique([userId, month])
  @@index([userId])
  @@index([month])
  @@map("api_usage")
}

model APIKey {
  id          String    @id @default(uuid())
  userId      String
  name        String
  keyHash     String    @unique
  keyPreview  String
  scopes      String
  expiresAt   DateTime?
  lastUsedAt  DateTime?
  isActive    Boolean   @default(true)
  rateLimit   Int       @default(1000)
  usageCount  Int       @default(0)
  windowStart DateTime  @default(now())
  ipWhitelist String?
  userAgent   String?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@index([userId])
  @@index([keyHash])
  @@index([isActive])
  @@map("api_keys")
}

model GeneratedDocument {
  id                String                @id @default(uuid())
  userId            String
  documentId        String                @unique
  generationType    String
  conversationId    String?
  isTemporary       Boolean               @default(true)
  expiresAt         DateTime?
  sourceDocumentIds String
  generationPrompt  String?
  renderableContent String
  metadata          String?
  generatedAt       DateTime              @default(now())
  savedAt           DateTime?

  document          Document              @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([documentId])
  @@index([generationType])
  @@index([conversationId])
  @@index([isTemporary])
  @@index([expiresAt])
  @@map("generated_documents")
}

model ExcelSheet {
  id          String      @id @default(uuid())
  documentId  String
  sheetIndex  Int
  sheetName   String
  rowCount    Int
  columnCount Int
  metadata    String?
  cachedAt    DateTime    @default(now())
  expiresAt   DateTime
  cells       ExcelCell[]

  @@unique([documentId, sheetIndex])
  @@index([documentId])
  @@index([expiresAt])
  @@map("excel_sheets")
}

model ExcelCell {
  id       String     @id @default(uuid())
  sheetId  String
  rowIndex Int
  colIndex Int
  value    String?
  formula  String?
  dataType String
  style    String?
  cachedAt DateTime   @default(now())
  sheet    ExcelSheet @relation(fields: [sheetId], references: [id], onDelete: Cascade)

  @@unique([sheetId, rowIndex, colIndex])
  @@index([sheetId])
  @@map("excel_cells")
}

model ActionHistory {
  id           String   @id @default(uuid())
  userId       String
  actionType   String
  targetPath   String
  previousPath String?
  fileContent  String?
  fileType     String?
  canUndo      Boolean  @default(true)
  canRedo      Boolean  @default(false)
  timestamp    DateTime @default(now())
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([canUndo])
  @@index([canRedo])
  @@index([timestamp])
  @@map("action_history")
}

model UserProfile {
  id             String   @id @default(uuid())
  userId         String   @unique
  name           String?
  role           String?
  organization   String?
  expertiseLevel String?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("user_profiles")
}

model UserPreference {
  id              String   @id @default(uuid())
  userId          String
  preferenceType  String
  preferenceValue String
  confidence      Float    @default(0.5)
  evidence        String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([userId, preferenceType])
  @@map("user_preferences_memory")
}

model ConversationTopic {
  id           String   @id @default(uuid())
  userId       String
  topicSummary String
  firstSeen    DateTime
  lastSeen     DateTime
  frequency    Int      @default(1)
  confidence   Float    @default(0.5)
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([userId, lastSeen])
  @@map("conversation_topics")
}

model Memory {
  id           String        @id @default(cuid())
  userId       String
  section      MemorySection
  content      String
  importance   Int           @default(5)
  createdAt    DateTime      @default(now())
  lastAccessed DateTime      @default(now())
  accessCount  Int           @default(0)
  source       String?
  metadata     Json?
  user         User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, section])
  @@index([userId, importance])
  @@index([lastAccessed])
  @@map("memories")
}

model MethodologyKnowledge {
  id                String   @id @default(uuid())
  userId            String
  name              String
  aliases           String?
  definition        String?
  howItWorks        String?
  whyUsed           String?
  limitations       String?
  useCases          String?
  examples          String?
  relatedMethods    String?
  parentMethod      String?
  childMethods      String?
  sourceDocumentIds String?
  documentCount     Int      @default(1)
  extractedFrom     String?
  confidence        Float    @default(0.5)
  isVerified        Boolean  @default(false)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  lastAccessedAt    DateTime @default(now())
  accessCount       Int      @default(0)

  @@unique([userId, name])
  @@index([userId])
  @@index([name])
  @@index([userId, name])
  @@index([confidence])
  @@index([documentCount])
  @@map("methodology_knowledge")
}

model DomainKnowledge {
  id                String                @id @default(uuid())
  userId            String
  term              String
  normalizedTerm    String
  domain            String
  definition        String?
  formula           String?
  interpretation    String?
  usageContext      String?
  examples          String?
  relatedTerms      String?
  parentTerm        String?
  childTerms        String?
  synonyms          String?
  sourceDocumentIds String?
  documentCount     Int                   @default(1)
  extractedContext  String?
  confidence        Float                 @default(0.5)
  isVerified        Boolean               @default(false)
  createdAt         DateTime              @default(now())
  updatedAt         DateTime              @updatedAt
  lastAccessedAt    DateTime              @default(now())
  accessCount       Int                   @default(0)
  outgoingRelations ConceptRelationship[] @relation("FromConcept")
  incomingRelations ConceptRelationship[] @relation("ToConcept")
  user              User                  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, normalizedTerm, domain])
  @@index([userId])
  @@index([term])
  @@index([normalizedTerm])
  @@index([domain])
  @@index([userId, domain])
  @@map("domain_knowledge")
}

model ConceptRelationship {
  id                String          @id @default(uuid())
  userId            String
  fromConceptId     String
  toConceptId       String
  relationshipType  String
  strength          Float           @default(0.5)
  description       String?
  sourceDocumentIds String?
  documentCount     Int             @default(1)
  createdAt         DateTime        @default(now())
  fromConcept       DomainKnowledge @relation("FromConcept", fields: [fromConceptId], references: [id], onDelete: Cascade)
  toConcept         DomainKnowledge @relation("ToConcept", fields: [toConceptId], references: [id], onDelete: Cascade)

  @@unique([fromConceptId, toConceptId, relationshipType])
  @@index([userId])
  @@index([fromConceptId])
  @@index([toConceptId])
  @@index([relationshipType])
  @@map("concept_relationships")
}

model CausalRelationship {
  id                String   @id @default(uuid())
  userId            String
  effect            String
  causes            String
  evidence          String?
  context           String?
  mechanism         String?
  domain            String?
  causalType        String?
  sourceDocumentIds String?
  documentCount     Int      @default(1)
  extractedPatterns String?
  confidence        Float    @default(0.5)
  isVerified        Boolean  @default(false)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  @@index([userId])
  @@index([userId, domain])
  @@index([confidence])
  @@map("causal_relationships")
}

model ComparativeData {
  id                    String   @id @default(uuid())
  userId                String
  conceptA              String
  conceptB              String
  attributes            String
  comparativeStatements String?
  keyInsight            String?
  similarities          String?
  differences           String?
  sourceDocumentIds     String?
  documentCount         Int      @default(1)
  confidence            Float    @default(0.5)
  isVerified            Boolean  @default(false)
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  @@unique([userId, conceptA, conceptB])
  @@index([userId])
  @@index([conceptA])
  @@index([conceptB])
  @@map("comparative_data")
}

model Presentation {
  id                 String    @id @default(uuid())
  userId             String
  title              String
  description        String?
  status             String    @default("draft")
  colorPalette       String?
  typography         String?
  aestheticDirection String?
  totalSlides        Int       @default(0)
  viewCount          Int       @default(0)
  lastViewedAt       DateTime?
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt
  user               User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  slides             Slide[]

  @@index([userId])
  @@index([status])
  @@index([createdAt])
  @@map("presentations")
}

model Slide {
  id             String       @id @default(uuid())
  presentationId String
  slideNumber    Int
  title          String
  summary        String?
  htmlContent    String
  layout         String
  template       String?
  status         String       @default("pending")
  errorMessage   String?
  generatedAt    DateTime?
  renderTime     Int?
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  presentation   Presentation @relation(fields: [presentationId], references: [id], onDelete: Cascade)

  @@unique([presentationId, slideNumber])
  @@index([presentationId])
  @@index([status])
  @@map("slides")
}

model ConversationChunk {
  id             String   @id @default(uuid())
  conversationId String
  userId         String
  startMessageId String
  endMessageId   String
  messageCount   Int      @default(0)
  content        String
  summary        String
  topics         String[]
  entities       String[]
  keywords       String[]
  vectorId       String?  @unique
  embeddingModel String   @default("text-embedding-004")
  importance     Float    @default(0.5)
  coherence      Float    @default(0.5)
  firstMessageAt DateTime
  lastMessageAt  DateTime
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  @@index([conversationId])
  @@index([userId])
  @@index([vectorId])
  @@index([conversationId, lastMessageAt])
  @@index([userId, lastMessageAt])
  @@map("conversation_chunks")
}

model ConversationIndex {
  id                    String   @id @default(uuid())
  conversationId        String   @unique
  userId                String
  title                 String
  summary               String
  mainTopics            String[]
  keyEntities           String[]
  keywords              String[]
  messageCount          Int      @default(0)
  chunkCount            Int      @default(0)
  userMessageCount      Int      @default(0)
  assistantMessageCount Int      @default(0)
  vectorId              String?  @unique
  embeddingModel        String   @default("text-embedding-004")
  firstMessageAt        DateTime
  lastMessageAt         DateTime
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  @@index([userId])
  @@index([vectorId])
  @@index([userId, lastMessageAt])
  @@map("conversation_indexes")
}

model ConversationContextState {
  id                   String    @id @default(uuid())
  conversationId       String    @unique
  userId               String
  recentMessageIds     String[]
  retrievedChunkIds    String[]
  memoryIds            String[]
  totalTokens          Int       @default(0)
  recentMessagesTokens Int       @default(0)
  chunksTokens         Int       @default(0)
  memoriesTokens       Int       @default(0)
  documentsTokens      Int       @default(0)
  isCompressed         Boolean   @default(false)
  compressionLevel     Int       @default(0)
  lastCompressedAt     DateTime?
  lastQuery            String?
  lastQueryEmbedding   Json?
  updatedAt            DateTime  @updatedAt

  @@index([conversationId])
  @@index([userId])
  @@map("conversation_context_states")
}

model AnalyticsDailyStat {
  id                 String   @id @default(uuid())
  date               DateTime @unique
  totalUsers         Int      @default(0)
  newUsers           Int      @default(0)
  activeUsers        Int      @default(0)
  totalConversations Int      @default(0)
  newConversations   Int      @default(0)
  totalMessages      Int      @default(0)
  userMessages       Int      @default(0)
  assistantMessages  Int      @default(0)
  totalDocuments     Int      @default(0)
  newDocuments       Int      @default(0)
  storageUsedBytes   BigInt   @default(0)
  errorCount         Int      @default(0)
  avgResponseTimeMs  Int      @default(0)
  estimatedCostUSD   Float    @default(0)
  geminiApiCalls     Int      @default(0)
  embeddingCalls     Int      @default(0)
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  @@index([date])
  @@map("analytics_daily_stats")
}

model AnalyticsUserActivity {
  id                   String    @id @default(uuid())
  userId               String
  date                 DateTime
  sessionsCount        Int       @default(0)
  messagesSent         Int       @default(0)
  documentsUploaded    Int       @default(0)
  conversationsCreated Int       @default(0)
  ragQueriesCount      Int       @default(0)
  totalActiveMinutes   Int       @default(0)
  lastActiveAt         DateTime?
  featuresUsed         String[]  @default([])
  createdAt            DateTime  @default(now())
  updatedAt            DateTime  @updatedAt

  @@unique([userId, date])
  @@index([userId])
  @@index([date])
  @@index([userId, date])
  @@map("analytics_user_activity")
}

model AnalyticsSystemHealth {
  id                  String   @id @default(uuid())
  timestamp           DateTime @default(now())
  databaseConnections Int      @default(0)
  databaseSizeBytes   BigInt   @default(0)
  slowQueryCount      Int      @default(0)
  requestsPerMinute   Int      @default(0)
  avgResponseTimeMs   Int      @default(0)
  errorRate           Float    @default(0)
  cpuUsagePercent     Float    @default(0)
  memoryUsagePercent  Float    @default(0)
  diskUsagePercent    Float    @default(0)
  pineconeLatencyMs   Int      @default(0)
  geminiLatencyMs     Int      @default(0)
  s3LatencyMs         Int      @default(0)

  @@index([timestamp])
  @@map("analytics_system_health")
}

model AnalyticsError {
  id              String    @id @default(uuid())
  timestamp       DateTime  @default(now())
  errorType       String
  errorCode       String?
  errorMessage    String
  stackTrace      String?
  endpoint        String?
  method          String?
  userId          String?
  requestBody     String?
  isResolved      Boolean   @default(false)
  resolvedAt      DateTime?
  resolvedBy      String?
  resolution      String?
  fingerprint     String?
  occurrenceCount Int       @default(1)
  firstOccurrence DateTime  @default(now())
  lastOccurrence  DateTime  @default(now())

  @@index([timestamp])
  @@index([errorType])
  @@index([fingerprint])
  @@index([isResolved])
  @@index([userId])
  @@map("analytics_errors")
}

model AdminAuditLog {
  id          String   @id @default(uuid())
  adminUserId String
  timestamp   DateTime @default(now())
  action      String
  resource    String?
  resourceId  String?
  ipAddress   String?
  userAgent   String?
  details     Json?

  @@index([adminUserId])
  @@index([timestamp])
  @@index([action])
  @@map("admin_audit_logs")
}

enum MemorySection {
  USER_PREFERENCES
  WORK_CONTEXT
  PERSONAL_FACTS
  GOALS
  COMMUNICATION_STYLE
  RELATIONSHIPS
}
